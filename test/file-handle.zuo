#lang zuo

(require "harness.zuo")

(alert "file handles")

(check (not (handle? 1)))
(check (not (handle? '(handle))))
(check eof eof)
(check (eq? eof eof))

(check (handle? (fd-open-input 'stdin)))
(check (handle? (fd-open-output 'stdout)))
(check (handle? (fd-open-output 'stderr)))
(check-fail (fd-open-output 'stdin) "not a path string")
(check-fail (fd-open-input 'stdout) "not a path string")
(check-fail (fd-open-input 'stderr) "not a path string")

(let ([out (fd-open-output (build-path tmp-dir "handle1.txt"))])
  (check (handle? out))
  (check (void? (fd-write out "one")))
  (check (void? (fd-close out)))
  (check (handle? out)))

(check-fail (let ([out (fd-open-output ,(build-path tmp-dir "handle2.txt"))])
              (fd-close out)
              (fd-close out))
            "not an open")

(let ([in (fd-open-input (build-path tmp-dir "handle1.txt"))])
  (check (handle? in))
  (check (fd-read in 1) "o")
  (check (fd-read in 2) "ne")
  (check (fd-read in 1) eof)
  (check (fd-read in 0) "")
  (check (void? (fd-close in)))
  (check (handle? in)))

(let ([in (fd-open-input (build-path tmp-dir "handle1.txt"))])
  (check (fd-read in eof) "one")
  (check (fd-read in 1) eof)
  (check (fd-read in eof) "")
  (check (void? (fd-close in))))

(check-fail (fd-open-output 'no) "not a path string")
(check-fail (fd-open-output "") "not a path string")
(check-fail (fd-open-input 'no) "not a path string")
(check-fail (fd-open-input "") "not a path string")
(check-fail (fd-read 'no 0) "not an open input")
(check-fail (fd-write 'no "") "not an open output")
(check-fail (fd-close 'oops) "not an open input or output")

(check-fail (fd-open-output ,(build-path (build-path tmp-dir "no-such-dir")
                                         "handle0.txt"))
            "file open failed")
  
(let ([not-there (build-path tmp-dir "handle0.txt")])
  (when (file-exists? not-there) (rm not-there))
  (check-fail (fd-open-input ,not-there) "file open failed"))

(let ()
  (define path (build-path tmp-dir "handle2.txt"))
  (define out (fd-open-output path))
  (define big (apply ~a (let loop ([i 10000])
                          (if (= i 0)
                              '()
                              (cons "hello" (loop (- i 1)))))))
  (fd-write out big)
  (fd-close out)
  (let ()
    (define in (fd-open-input path))
    (check (equal? big (fd-read in eof)))
    (check (fd-read in 1) eof)
    (fd-close in))
  (let ()
    (define in (fd-open-input path))
    (define len (quotient (string-length big) 2))
    (check (equal? (fd-read in len) (substring big 0 len)))
    (check (fd-read in 1) (string (string-ref big len)))
    (fd-close in)))
