#lang zuo

(define (current-program) (hash-ref (runtime-env) 'script "image.zuo"))

(define (need-arg args)
  (when (null? (cdr args))
    (error (~a (current-program) ": flag " (car args) " needs an argument"))))

(define cmd
  (let loop ([args (hash-ref (runtime-env) 'args #f)] [cmd (hash)])
    (cond
      [(null? args) cmd]
      [(string=? (car args) "-o")
       (need-arg args)
       (loop (cddr args) (hash-set cmd 'output (cadr args)))]
      [(or (string=? (car args) "+l") (string=? (car args) "++lib"))
       (need-arg args)
       (loop (cddr args) (hash-set cmd 'libs (cons (cadr args)
                                                   (hash-ref cmd 'libs '()))))]
      [(string=? (car args) "--keep-collects")
       (loop (cdr args) (hash-set cmd 'keep-collects? #t))]
      [else
       (error (~a (current-program) ": unrecognized argument " (car args)))])))

(define given-libs (hash-ref cmd 'libs '()))
(define libs (if (null? given-libs)
                 '(zuo)
                 given-libs))

(define image
  (let ([ht (process (hash-ref (runtime-env) 'exe #f) "" (hash 'stdin 'pipe 'stdout 'pipe))])
    (define p (hash-ref ht 'process #f))
    (define in (hash-ref ht 'stdin #f))
    (define out (hash-ref ht 'stdout #f))
    (fd-write in "#lang zuo/kernel\n")
    (fd-write in "(begin\n")
    (for-each (lambda (lib)
                (fd-write in (~a "(module->hash '" lib ")\n")))
              libs)
    (fd-write in "(dump-image-and-exit (fd-open-output 'stdout (hash))))\n")
    (fd-close in)
    (let ([image (fd-read out eof)])
      (fd-close out)
      (process-wait p)
      (unless (= 0 (process-status p))
        (error "image dump failed"))
      image)))

(define out-file (hash-ref cmd 'output #f))

(define zuo.c (fd-read (fd-open-input (quote-path "zuo.c")) eof))
(define out (if out-file
                (fd-open-output out-file (hash 'exists 'truncate))
                (fd-open-output 'stdout (hash))))

(define lines
  (let loop ([start 0] [i 0])
    (cond
      [(= i (string-length zuo.c))
       (if (= start i)
           '()
           (list (substring zuo.c start i)))]
      [(= (string-ref zuo.c i) (char "\n"))
       (cons (substring zuo.c start i)
             (loop (+ i 1) (+ i 1)))]
      [else (loop start (+ i 1))])))

(define (~hex v)
  (if (= v 0)
      "0"
      (let loop ([v v] [accum '()])
        (if (= v 0)
            (apply ~a accum)
            (loop (quotient v 16)
                  (cons (let ([i (bitwise-and v 15)])
                          (substring "0123456789abcdef" i (+ i 1)))
                        accum))))))

(define embedded-image-line "#define EMBEDDED_IMAGE 0")
(define embedded-image-line/cr (~a embedded-image-line "\r"))

(for-each
 (lambda (line)
   (cond
     [(or (string=? line embedded-image-line)
	  (string=? line embedded-image-line/cr))
      (define nl (if (string=? line embedded-image-line/cr) "\r\n" "\n"))
      (unless (hash-ref cmd 'keep-collects? #f)
        (fd-write out (~a "#define ZUO_LIB_PATH NULL" nl)))
      (fd-write out (~a "#define EMBEDDED_IMAGE 1" nl))
      (fd-write out (~a "static zuo_uint32_t emedded_boot_image_len = "
                        (quotient (string-length image) 4)
                        ";" nl))
      (fd-write out (~a "static zuo_uint32_t emedded_boot_image[] = {" nl))
      (let ([accum->line (lambda (accum) (apply ~a (reverse (cons nl accum))))])
        (let loop ([i 0] [col 0] [accum '()])
          (cond
            [(= i (string-length image))
             (unless (null? accum)
               (fd-write out (accum->line accum)))]
            [(= col 8)
             (fd-write out (accum->line accum))
             (loop i 0 '())]
            [else
             (loop (+ i 4) (+ col 1)
                   (cons (~a " 0x" (~hex (string-u32-ref image i)) ",")
                         accum))])))
      (fd-write out (~a " 0 };" nl))]
     [else
      (fd-write out (~a line "\n"))]))
 lines)
