#lang zuo/base
(require "struct.zuo"
         "cmdline.zuo"
         "thread.zuo")

;; A target is
;;    (list name )

(provide target?
         (rename-out [make-target target]
                     [make-rule rule])
         target-name
         target-path
         timestamp?
         timestamp-later?
         file-target
         file-timestamp
         build
         build/command-line
         provide-builder)

(struct build-state (dest-dir target-state resource-ch))

(struct target (key
                name
                get-deps ; (name build-state -> rule)
                options))

(struct rule (deps
              timestamp
              build)) ; (name build-state -> new-timestamp)

(define make-target
  (let ([target
         (lambda (name get-deps [options (hash)])
           (unless (path-string? name) (arg-error 'target "path string" name))
           (unless (procedure? get-deps) (arg-error 'target "procedure" get-deps))
           (unless (hash? options) (arg-error 'target "hash table" options))
           (target (string->uninterned-symbol name) name get-deps options))])
    target))

(define make-rule
  (let ([rule
         (lambda (deps timestamp [build #f])
           (unless (and (list? deps)
                        (andmap target? deps))
             (arg-error 'rule "list of targets" deps))
           (unless (timestamp? timestamp)
             (arg-error 'rule "timestamp" timestamp))
           (unless (or (not build)
                       (procedure? build))
             (arg-error 'rule "procedure or #f" build))
           (rule deps timestamp build))])
    rule))

(define (target-path t state)
  (define name (target-name t))
  (if (and (relative-path? name)
           (build-state-dest-dir state))
      (build-path (build-state-dest-dir state) name)
      name))

(define (timestamp? v)
  (or (eq? v 'before)
      (eq? v 'after)
      (and (pair? v)
           (integer? (car v))
           (integer? (cdr v)))))

(define (timestamp-later? a b)
  (cond
    [(eq? a 'before) #f]
    [(eq? b 'before) #t]
    [(eq? b 'after) #f]
    [(eq? a 'after) #t]
    [(> (car a) (car b)) #t]
    [(< (car a) (car b)) #f]
    [else (> (cdr a) (cdr b))]))

(define (file-target path)
  (make-target path
               (lambda (path state)
                 (let ([ts (file-timestamp path)])
                   (if (eq? ts 'before)
                       (error "missing input file" path)
                       (make-rule '() ts))))))

(define (file-timestamp path)
  (let ([s (stat path)])
    (if s
        (cons (hash-ref s 'modify-time-seconds)
              (hash-ref s 'modify-time-nanoseconds))
        'before)))

(define (target-state state t)
  (hash-ref (build-state-target-state state) (target-key t) #f))

(define (update-target-state state t ts)
  (build-state-set-target-state state
                                (hash-set (build-state-target-state state)
                                          (target-key t)
                                          ts)))

(define (make-resources n)
  (define ch (channel))
  (let loop ([n n])
    (unless (= n 0)
      (channel-put ch 'go)
      (loop (- n 1))))
  ch)

(define (acquire-resource state)
  (channel-get (build-state-resource-ch state))
  (void))

(define (release-resource state)
  (channel-put (build-state-resource-ch state) 'go))

(define (build t [options (hash)])
  (unless (target? t) (arg-error 'build "target" t))
  (call-in-main-thread
   (lambda ()
     (do-build t (build-state (hash-ref options 'dest-dir #f)
                              (hash)
                              (make-resources (hash-ref options 'jobs 1))) #t)))
  (void))

(define (do-build t state top?)
  (define current (target-state state t))
  (cond
    [(not current) (build-unbuilt t state top?)]
    [(eq? current 'pending) (error "build: dependency cycle" (target-path t state))]
    [(channel? current) state]
    [else state]))

(define (force-build t state)
  (define current (target-state state t))
  (cond
    [(channel? current) (update-target-state state t (channel-get current))]
    [else state]))

(define (build-unbuilt t state top?)
  (call/cc
   (lambda (suspend-esc)
     (define pre (current-time))
     (define path (target-path t state))
     (define path-handle (cleanable-file path))
     
     (define r ((target-get-deps t) path state))
     (unless (rule? r)
       (error "build: target result is not a rule" r))
     
     (define deps (rule-deps r))
     (define ts (rule-timestamp r))
     (define to-build (rule-build r))

     (define pending-state (update-target-state state t 'pending))

     (define fetch-state
       (foldl (lambda (dep state) (do-build dep state #f))
              pending-state
              deps))
     (define new-state
       (foldl (lambda (dep state) (force-build dep state))
              fetch-state
              deps))
     
     (define dep-tss
       (let ([target-state (build-state-target-state new-state)])
         (map (lambda (dep)
                (hash-ref target-state (target-key dep) #f))
              deps)))
     (cond
       [(ormap (lambda (dep-ts) (timestamp-later? dep-ts ts))
               dep-tss)
        (unless to-build
          (error "build: out-of-date target has no build procedure" (target-name t)))
        (let ([ch (channel)])
          (thread (lambda ()
                    (acquire-resource new-state)
                    (let ([ts (to-build new-state)])
                      (unless (timestamp? ts)
                        (error "build: target-build result is not a timestamp" ts))
                      (cleanable-cancel path-handle)
                      (channel-put ch ts)
                      (release-resource new-state))))
          (update-target-state new-state t ch))]
       [else
        (cleanable-cancel path-handle)
        (when (and (or top? (hash-ref (target-options t) 'noisy? #f))
                   (timestamp-later? pre ts))
          (alert (~a (target-name t) " is up to date")))
        (update-target-state new-state t ts)]))))

(define (build/command-line targets [wrt #f] [opts (hash)])
  (unless (and (list? targets) (andmap target? targets))
    (arg-error 'build/command-line "list of targets" targets))
  (unless (or (not wrt) (path-string? wrt))
    (arg-error 'build/command-line "path string or #f" opts))
  (unless (hash? opts)
    (arg-error 'build/command-line "hash table" opts))
  (command-line
   :argv (or (hash-ref opts 'args #f) (hash-ref (runtime-env) 'args))
   :init (if (or (hash-ref opts 'dest-dir #f) (not wrt))
             opts
             (hash-set opts 'dest-dir (find-relative-directory wrt)))
   :once-each
   [opts ("-j" "--jobs") n "Use <n> parallel jobs"
         (let ([v (read-from-string-all n)])
           (if (and (= 1 (length v))
                    (integer? (car v))
                    (> (car v) 0))
               (hash-set opts 'jobs (car v))
               (error "not a positive integer" n)))]
   :args
   ([target (target-name (car targets))])
   (lambda (opts)
     (build (or (ormap (lambda (t) (and (equal? target (target-name t)) t))
                       targets)
                (error (~a "unknown target: " target)))
            opts))))

(define-syntax (provide-builder stx)
  (unless (and (list? stx) (= 2 (length stx)))
    (bad-syntax stx))
  (define targets (string->uninterned-symbol "targets"))
  (define builder (datum->syntax (car stx) 'builder))
  (list (quote-syntax begin)
        (list (quote-syntax provide) builder)
        (list (quote-syntax define) targets (cadr stx))
        (list (quote-syntax define)
              (list builder
                    'wrt)
              (list (quote-syntax build/command-line)
                    targets
                    'wrt))
        (list (quote-syntax module+) 'main
              (list builder #f))))

(define (find-relative-directory wrt)
  (define l (split-path wrt))
  (cond
    [(not l) (if (relative-path? wrt)
                 #f
                 wrt)]
    [(relative-path? (car l)) (car l)]
    [else (find-relative-path (car l) (hash-ref (runtime-env) 'dir))]))
