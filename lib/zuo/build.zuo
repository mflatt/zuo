#lang zuo/base
(require "cmdline.zuo"
         "thread.zuo"
         "private/build-db.zuo")

(provide target?
         (rename-out [make-target target]
                     [make-rule rule])
         input-file-target

         target-name
         target-path

         file-sha1
         no-sha1
         done-sha1

         build
         build/command-line
         provide-builder)

;; ------------------------------------------------------------
;; Targets and rules

(struct target (key       ; a gensym to serve as a hash-table key
                name      ; a path relative to the build directory (not current or source directory)
                get-rule  ; (path build-state -> rule), where `path` is relative to current directory
                options)) ; 'input, 'precious?, etc.

;; result from `get-rule`:
(struct rule (deps        ; list of targets
              sha1        ; current SHA-1
              build))     ; (path build-state -> new-sha1), called when deps SHA-1s different than recorded

(define no-sha1 "")
(define done-sha1 "x")
(define (sha1? s)
  (and (string? s)
       (or (= (string-length s) 40)
           (string=? s no-sha1)
           (string=? s done-sha1))))

;; public constructor
(define make-target
  (let ([target
         (lambda (name get-rule [options (hash)])
           (unless (path-string? name) (arg-error 'target "path string" name))
           (unless (procedure? get-rule) (arg-error 'target "procedure" get-rule))
           (unless (hash? options) (arg-error 'target "hash table" options))
           (target (string->uninterned-symbol name) name get-rule options))])
    target))

;; public constructor
(define make-rule
  (let ([rule
         (lambda (deps sha1 [build #f])
           (unless (and (list? deps)
                        (andmap target? deps))
             (arg-error 'rule "list of targets" deps))
           (unless (sha1? sha1)
             (arg-error 'rule "sha1?" sha1))
           (unless (or (not build)
                       (procedure? build))
             (arg-error 'rule "procedure or #f" build))
           (rule deps sha1 build))])
    rule))

;; An input-file target has no dependencies
(define (input-file-target path)
  (make-target path
               (lambda (path state)
                 (let ([sha1 (file-sha1 path state)])
                   (if (equal? sha1 no-sha1)
                       (error "missing input file" path)
                       (make-rule '() sha1))))
               (hash 'input? #t)))

;; Resolves a target's path, which is relative to a build directory,
;; to a path that is relative to the current directory
(define (target-path t state)
  (define name (target-name t))
  (if (and (relative-path? name)
           (build-state-dest-dir state))
      (build-path (build-state-dest-dir state) name)
      name))

;; As the name says: like `target-path` but absolute
(define (target-absolute-path t state)
  (path->absolute-path (target-path t state)))

;; ------------------------------------------------------------
;; Build state and loop

;; When a target is built, the build result is recorded as
;;
;;   (list sha1 (list dep-path-rel-to-target sha1) ..)
;;
;; This result is in the `target-state` field of a build state, while
;; `db` holds the same-shaped information from the previous build (but
;; mapped by absolute path in symbol form, instead of key).
;;
;; The `time-cache` field of a build state is a shortcut for getting
;; input-file SHA-1s on the assumption that a SHA-1 recorded last time
;; is still right if the file's timestamp hasn't changed.

(struct build-state (dest-dir      ; build path relative to current directory; #f is like "."
                     target-state  ; key -> (cons sha1 dep-sha1s) | 'pending | channel
                     db            ; absolute-path -> (cons sha1 dep-sha1s) | #t [for db file itself]
                     time-cache    ; absolute-path -> (cons timestamp sha1) 
                     resource-ch)) ; channel with available resources enqueued

;; Main entry point to build a target `t`
(define (build t [options (hash)])
  (unless (target? t) (arg-error 'build "target" t))
  ;; Start a threading context, so we can have parallel build tasks
  (call-in-main-thread
   (lambda ()
     (define state (build-state (hash-ref options 'dest-dir #f)
                                (hash)
                                (hash)
                                (hash)
                                (make-resources (hash-ref options 'jobs 1))))
     (force-build t (do-build t state #t))))
  (void))

;; Detects already built or cycles, but leaves in-progress (as
;; represented by a channel) alone
(define (do-build t state top?)
  (define current (target-state state t))
  (cond
    [(not current) (build-unbuilt t state top?)]
    [(eq? current 'pending) (error "build: dependency cycle" (target-path t state))]
    [(channel? current) state]
    [else state]))

;; Blocks until an in-progress target completes
(define (force-build t state)
  (define current (target-state state t))
  (cond
    [(channel? current) (update-target-state/record-sha1s state t (channel-get current))]
    [else state]))

;; Starts a build for a specific target
(define (build-unbuilt t state top?)
  (define path (target-path t state))
  (define abs-path (path->absolute-path path))

  ;; delete a target file if we don't finish:
  (define path-handle (and (not (hash-ref (target-options t) 'precious? #f))
                           (cleanable-file path)))

  (define pending-state (update-target-state state t 'pending))

  ;; first phase of the target: get a rule
  (define r ((target-get-rule t) path pending-state))
  (unless (rule? r)
    (error "build: target result is not a rule" r))
  (define deps (rule-deps r))
  (define sha1 (rule-sha1 r))
  (define to-build (rule-build r))

  ;; get previously recorded result, possibly loading from a file
  ;; that is cached in the build state
  (define loaded-state (load-sha1s pending-state t abs-path))

  (define prev-ts (previous-target-state loaded-state abs-path))
  (define prev-sha1 (car prev-ts))
  (define prev-dep-sha1s (cdr prev-ts))

  ;; trigger builds of dependencies, but don't want for them to complete
  (define fetch-state
    (foldl (lambda (dep state) (do-build dep state #f))
           loaded-state
           deps))

  ;; now that they're all potentially started, wait for completions
  (define new-state
    (foldl (lambda (dep state) (force-build dep state))
           fetch-state
           deps))

  ;; extract results, assemble in a list of `(list <rel-path> <sha1>)`
  (define dep-sha1s
    (let ([target-dir (car (split-path abs-path))])
      (map (lambda (dep)
             (define rel-path (find-relative-path target-dir
                                                  (target-absolute-path dep new-state)))
             (define ts (target-state new-state dep))
             (list rel-path (car ts)))
           deps)))

  ;; compare to recorded result, and rebuild if different
  (cond
    [(and (not (and (equal? dep-sha1s prev-dep-sha1s)
                    (or (not to-build)
                        (equal? sha1 prev-sha1))))
          (not (equal? sha1 done-sha1)))
     (unless to-build
       (error "build: out-of-date target has no build procedure" (target-name t)))
     ;; always run a build for a dependency in its own thread
     (let ([ch (channel)])
       (thread (lambda ()
                 (acquire-resource new-state) ; limits process parallelism
                 (let ([sha1 (to-build new-state)]) ; build!
                   (unless (sha1? sha1)
                     (error "build: target-build result is not a sha1" sha1))
                   (when path-handle (cleanable-cancel path-handle))
                   (channel-put ch (cons sha1 dep-sha1s))
                   (release-resource new-state))))
       ;; meanwhile, record a channel as the start's current build state
       (update-target-state new-state t ch))]
    [else
     ;; no need to rebuild
     (when path-handle (cleanable-cancel path-handle))
     (when (and (or top? (hash-ref (target-options t) 'noisy? #f))
                (equal? prev-sha1 sha1)
                (not (equal? sha1 done-sha1)))
       (alert (~a (target-name t) " is up to date")))
     (update-target-state new-state t (cons sha1 dep-sha1s))]))

;; Alterntaive entry point suiable for use from a script's `main`
(define (build/command-line targets [wrt #f] [opts (hash)])
  (unless (and (list? targets) (andmap target? targets))
    (arg-error 'build/command-line "list of targets" targets))
  (unless (or (not wrt) (path-string? wrt))
    (arg-error 'build/command-line "path string or #f" opts))
  (unless (hash? opts)
    (arg-error 'build/command-line "hash table" opts))
  (command-line
   :argv (or (hash-ref opts 'args #f) (hash-ref (runtime-env) 'args))
   :init (if (or (hash-ref opts 'dest-dir #f) (not wrt))
             opts
             (hash-set opts 'dest-dir (find-relative-directory wrt)))
   :once-each
   [opts ("-j" "--jobs") n "Use <n> parallel jobs"
         (let ([v (read-from-string-all n)])
           (if (and (= 1 (length v))
                    (integer? (car v))
                    (> (car v) 0))
               (hash-set opts 'jobs (car v))
               (error "not a positive integer" n)))]
   :args
   ([target (target-name (car targets))])
   (lambda (opts)
     (build (or (ormap (lambda (t) (and (equal? target (target-name t)) t))
                       targets)
                (error (~a "unknown target: " target)))
            opts))))

;; Defines and exports `builder` and `targets` while also setting up a
;; `main` submodule to call `builder`
(define-syntax (provide-builder stx)
  (unless (and (list? stx) (= 2 (length stx)))
    (bad-syntax stx))
  (define targets (string->uninterned-symbol "targets"))
  (define builder (datum->syntax (car stx) 'builder))
  (list (quote-syntax begin)
        (list (quote-syntax provide) builder targets)
        (list (quote-syntax define) targets (cadr stx))
        (list (quote-syntax define)
              (list builder
                    'wrt)
              (list (quote-syntax build/command-line)
                    targets
                    'wrt))
        (list (quote-syntax module+) 'main
              (list builder #f))))

;; ------------------------------------------------------------
;; Helpers for reading and updating build state

(define (target-state state t)
  (hash-ref (build-state-target-state state) (target-key t) #f))

(define (update-target-state state t ts)
  (build-state-set-target-state state
                                (hash-set (build-state-target-state state)
                                          (target-key t)
                                          ts)))

(define (update-target-state/record-sha1s state t ts)
  (record-target-sha1s state t ts)
  (update-target-state state t ts))

(define (record-target-sha1s state t ts)
  (unless (hash-ref (target-options t) 'input?  #f)
    (db-record-target-sha1s (target-absolute-path t state) ts)))

(define (load-sha1s state t abs-path)
  (cond
    [(hash-ref (target-options t) 'input? #f) state]
    [else
     (define db+tc (db-load-sha1s abs-path (build-state-db state)
                                  (build-state-time-cache state)))
     (if db+tc
         (let ([state (build-state-set-db state (car db+tc))])
           (build-state-set-time-cache state (cdr db+tc)))
         state)]))

(define (previous-target-state state abs-path)
  (hash-ref (build-state-db state)
            (string->symbol abs-path)
            '("")))

(define (file-sha1 path [state #f])
  (or (file-sha1/cached path (and state (build-state-time-cache state)))
      no-sha1))

;; see also "private/build-db.zuo"

;; ------------------------------------------------------------
;; Generic helpers

(define (find-relative-directory wrt)
  (define l (split-path wrt))
  (cond
    [(not l) (if (relative-path? wrt)
                 #f
                 wrt)]
    [(relative-path? (car l)) (car l)]
    [else (find-relative-path (car l) (hash-ref (runtime-env) 'dir))]))

(define (make-resources n)
  (define ch (channel))
  (let loop ([n n])
    (unless (= n 0)
      (channel-put ch 'go)
      (loop (- n 1))))
  ch)

(define (acquire-resource state)
  (channel-get (build-state-resource-ch state))
  (void))

(define (release-resource state)
  (channel-put (build-state-resource-ch state) 'go))
