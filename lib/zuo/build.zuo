#lang zuo/base
(require "struct.zuo"
         "cmdline.zuo")

;; A target is
;;    (list name )

(provide target?
         (rename-out [make-target target]
                     [make-rule rule])
         target-name
         target-path
         timestamp?
         timestamp-later?
         file-target
         file-timestamp
         build
         build-command-line)

(struct build-state (dest-dir target-state suspend-k))

(struct target (key
                name
                get-deps ; (build-state -> rule)
                options))

(struct rule (deps
              timestamp
              build)) ; (build-state -> new-timestamp)

(define make-target
  (let ([target
         (lambda (name get-deps [options (hash)])
           (unless (path-string? name) (arg-error 'target "path string" name))
           (unless (procedure? get-deps) (arg-error 'target "procedure" get-deps))
           (unless (hash? options) (arg-error 'target "hash table" options))
           (target (string->uninterned-symbol name) name get-deps options))])
    target))

(define make-rule
  (let ([rule
         (lambda (deps timestamp [build #f])
           (unless (and (list? deps)
                        (andmap target? deps))
             (arg-error 'rule "list of targets" deps))
           (unless (timestamp? timestamp)
             (arg-error 'rule "timestamp" timestamp))
           (unless (or (not build)
                       (procedure? build))
             (arg-error 'rule "procedure or #f" build))
           (rule deps timestamp build))])
    rule))

(define (target-path t state)
  (define name (target-name t))
  (if (relative-path? name)
      (build-path (build-state-dest-dir state) name)
      name))

(define (timestamp? v)
  (or (eq? v 'before)
      (eq? v 'after)
      (and (pair? v)
           (integer? (car v))
           (integer? (cdr v)))))

(define (timestamp-later? a b)
  (cond
    [(eq? a 'before) #f]
    [(eq? b 'before) #t]
    [(eq? b 'after) #f]
    [(eq? a 'after) #t]
    [(> (car a) (car b)) #t]
    [(< (car a) (car b)) #f]
    [else (> (cdr a) (cdr b))]))

(define (file-target path)
  (make-target path
               (lambda (state)
                 (let ([ts (file-timestamp path)])
                   (if (eq? ts 'before)
                       (error "missing input file" path)
                       (make-rule '() ts))))))

(define (file-timestamp path)
  (let ([s (stat path)])
    (if s
        (cons (hash-ref s 'modify-time-seconds)
              (hash-ref s 'modify-time-nanoseconds))
        'before)))

(define (target-state state t)
  (hash-ref (build-state-target-state state) (target-key t) #f))

(define (update-target-state state t ts)
  (build-state-set-target-state state
                                (hash-set (build-state-target-state state)
                                          (target-key t)
                                          ts)))

(define (build t dest-dir)
  (unless (target? t) (arg-error 'build "target" t))
  (do-build t (build-state dest-dir (hash) #f) #t)
  (void))

(define (do-build t state top?)
  (define current (target-state state t))
  (cond
    [(not current) (build-unbuilt t state top?)]
    [(eq? current 'pending) (error "build: dependency cycle" (target-path t state))]
    [else state]))

(define (build-unbuilt t state top?)
  (call/cc
   (lambda (suspend-esc)
     (define pre (current-time))

     (define r ((target-get-deps t) state))
     (unless (rule? r)
       (error "build: target result is not a rule" r))
     
     (define deps (rule-deps r))
     (define ts (rule-timestamp r))
     (define to-build (rule-build r))

     (define pending-state (update-target-state state t 'pending))

     (define new-state
       (foldl (lambda (dep state) (do-build dep state #f))
              pending-state
              deps))
     
     (define dep-tss
       (let ([target-state (build-state-target-state new-state)])
         (map (lambda (dep)
                (hash-ref target-state (target-key dep) #f))
              deps)))
     (cond
       [(ormap (lambda (dep-ts) (timestamp-later? dep-ts ts))
               dep-tss)
        (unless to-build
          (error "build: out-of-date target has no build procedure" (target-name t)))
        (let ([ts (to-build new-state)])
          (unless (timestamp? ts)
            (error "build: target-build result is not a timestamp" ts))
          (update-target-state new-state t ts))]
       [else
        (when (and (or top? (hash-ref (target-options t) 'noisy? #f))
                   (timestamp-later? pre ts))
          (alert (~a (target-name t) " is up to date")))
        (update-target-state new-state t ts)]))))

(define-syntax (build-command-line stx)
  (unless (and (list? stx)
               (= (length stx) 2))
    (bad-syntax stx))
  `(,(quote-syntax do-build-command-line)
    ,(quote-syntax (quote-module-path))
    ,(cadr stx)))

(define (do-build-command-line wrt targets)
  (command-line
   :args
   ([target (target-name (car targets))])
   (lambda (opts)
     (build (or (ormap (lambda (t) (and (equal? target (target-name t)) t))
                       targets)
                (error (~a "unknown target: " target)))
            (car (split-path wrt))))))
