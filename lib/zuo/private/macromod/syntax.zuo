#lang zuo/datum

(define make-scope (lambda (name) (string->uninterned-symbol name)))
(define set-add (lambda (ht v) (hash-set ht v #t)))
(define set-remove hash-remove)
(define set-flip (lambda (ht v)
                   (let ([ht2 (hash-remove ht v)])
                     (if (eq? ht ht2)
                         (hash-set ht v #t)
                         ht2))))

(define scope-set=?
  (lambda (sc1 sc2)
    (and (hash-keys-subset? sc1 sc2)
         (hash-keys-subset? sc2 sc1))))

(define syntax-tag (string->uninterned-symbol "syntax"))
(define identifier (lambda (id scopes) (opaque syntax-tag (cons id scopes))))
(define identifier? (lambda (v) (symbol? (car (opaque-ref syntax-tag v '(#f . #f))))))
(define syntax-e (lambda (v) (car (opaque-ref syntax-tag v #f))))
(define identifier-scopes (lambda (v) (cdr (opaque-ref syntax-tag v #f))))

(define datum->syntax
  (letrec ([datum->syntax (lambda (ctx v)
                            (cond
                              [(symbol? v) (identifier v (identifier-scopes ctx))]
                              [(pair? v) (cons (datum->syntax ctx (car v))
                                               (datum->syntax ctx (cdr v)))]
                              [else v]))])
    datum->syntax))

(define syntax->datum
  (letrec ([syntax->datum (lambda (s)
                            (cond
                              [(identifier? s) (syntax-e s)]
                              [(pair? s) (cons (syntax->datum (car s))
                                               (syntax->datum (cdr s)))]
                              [else s]))])
    syntax->datum))

(define adjust-scope
  (letrec ([adjust-scope
            (lambda (s scope op)
              (cond
                [(pair? s) (cons (adjust-scope (car s) scope op)
                                 (adjust-scope (cdr s) scope op))]
                [(identifier? s) (identifier (syntax-e s)
                                             (op (identifier-scopes s) scope))]
                [else s]))])
    adjust-scope))

(define add-scope (lambda (s scope) (adjust-scope s scope set-add)))
(define remove-scope (lambda (s scope) (adjust-scope s scope set-remove)))
(define flip-scope (lambda (s scope) (adjust-scope s scope set-flip)))

(define empty-binds (hash))
(define binds-set-context (lambda (binds ctx) binds))
(define top-binding-syms hash-keys)
(define top-binding-ref hash-ref)

(define add-binding*
  (lambda (binds id binding)
    (let* ([sym (syntax-e id)]
           [sc (identifier-scopes id)]
           [sym-binds (hash-ref binds sym (hash))]
           [k-scope (car (hash-keys sc))] ; relying on deterministic order
           [sc+bs (hash-ref sym-binds k-scope '())]
           [sym-binds (hash-set sym-binds k-scope (cons (cons sc binding) sc+bs))])
      (hash-set binds sym sym-binds))))

(define find-all-matching-bindings
  (lambda (binds id)
    (let* ([sym (syntax-e id)]
           [id-sc (identifier-scopes id)]
           [sym-binds (hash-ref binds sym #f)])
      (if (not sym-binds)
          '()
          (foldl (lambda (scope lst)
                   (foldl (lambda (sc+b lst)
                            (let* ([sc (car sc+b)])
                              (if (hash-keys-subset? sc id-sc)
                                  (cons sc+b lst)
                                  lst)))
                          lst
                          (hash-ref sym-binds scope '())))
                 '()
                 (hash-keys sym-binds))))))

(define check-unambiguous
  (lambda (id max-sc+b candidate-sc+bs)
    (map (lambda (sc+b)
           (unless (hash-keys-subset? (car sc+b)
                                      (car max-sc+b))
             (error "ambiguous" (syntax-e id))))
         candidate-sc+bs)))

(define resolve*
  (lambda (binds id)
    (let* ([candidate-sc+bs (find-all-matching-bindings binds id)])
      (cond
        [(pair? candidate-sc+bs)
         (let* ([max-sc+binding (foldl (lambda (sc+b max-sc+b)
                                         (if (> (hash-count (car max-sc+b))
                                                (hash-count (car sc+b)))
                                             max-sc+b
                                             sc+b))
                                       (car candidate-sc+bs)
                                       (cdr candidate-sc+bs))])
           (check-unambiguous id max-sc+binding candidate-sc+bs)
           (cdr max-sc+binding))]
        [else #f]))))

(define bound-identifier=?
  (lambda (id1 id2)
    (unless (identifier? id1) (error "bound-identifier=?: not an identifier" id1))
    (unless (identifier? id2) (error "bound-identifier=?: not an identifier" id2))
    (and (eq? (syntax-e id1) (syntax-e id2))
         (scope-set=? (identifier-scopes id1)
                      (identifier-scopes id2)))))

(define merge-binds*
  (lambda (binds key m-binds)
    ;; merge bindings from `m-binds` to `binds`:
    (foldl (lambda (sym binds)
             (let* ([sym-ht (hash-ref binds sym (hash))]
                    [m-sym-ht (hash-ref m-binds sym #f)]
                    [new-sym-ht
                     (foldl (lambda (s sym-ht)
                              (hash-set sym-ht
                                        s
                                        (append (hash-ref m-sym-ht s '())
                                                (hash-ref sym-ht s '()))))
                            sym-ht
                            (hash-keys m-sym-ht))])
               (hash-set binds sym new-sym-ht)))
           binds
           (hash-keys m-binds))))

;; called on a binding table that just has the initial imports,
;; extracts an association list of symbol to bindings
(define extract-initial-binds
  (lambda (binds)
    (foldl (lambda (sym sym+bs)
             (let* ([sym-ht (hash-ref binds sym #f)])
               (foldl (lambda (scope sym+bs)
                        (let ([sc+bs (hash-ref sym-ht scope #f)])
                          (foldl (lambda (sc+b sym+bs)
                                   (cons (cons sym (cdr sc+b))
                                         sym+bs))
                                 sym+bs
                                 sc+bs)))
                      sym+bs
                      (hash-keys sym-ht))))
           '()
           (hash-keys binds))))

(include "../mm-common/free-id-eq.zuo")

(define core-sc (hash 'core #t))

(define make-core-bind
  (lambda (bind)
    (hash 'core (list (cons core-sc bind)))))

(define add-core-binding
  (lambda (binds sym core-bind)
    (hash-set binds sym core-bind)))

(define syntax-quote
  (lambda (v ctx)
    (list 'quote v)))

(define apply-macro
  (lambda (m s ctx state k)
    (let* ([apply-macro
            (lambda (proc ctx state)
              (let* ([new-scope (make-scope "macro")]
                     [s (add-scope s new-scope)]
                     [s (if (= 4 (bitwise-and (procedure-arity-mask proc) 4))
                            (proc s (lambda (a b) (free-id=? state (datum->syntax ctx a) (datum->syntax ctx b))))
                            (proc s))]
                     [s (datum->syntax ctx s)]
                     [s (flip-scope s new-scope)])
                (k s state)))])
      (cond
        [(defined-macro? m) (apply-macro (defined-macro-proc m) ctx state)]
        [else
         (let* ([implementation (macro-implementation m)]
                [proc (car implementation)]
                [key (cadr implementation)]
                [ctx (cadr (cdr implementation))]
                [m-binds (cadr (cddr implementation))])
           (apply-macro proc ctx (merge-binds state key m-binds merge-binds*)))]))))

(define make-module-context
  (lambda (mod-path)
    (let* ([mod-scope (make-scope "module")]
           [ctx (identifier 'module (set-add core-sc mod-scope))])
      ctx)))

(define make-exported-macro
  (lambda (proc ctx binds)
    (let ([mod-scope (ormap (lambda (s)
                              (and (not (eq? s 'core)) s))
                            (hash-keys (identifier-scopes ctx)))])
      (make-macro (list proc mod-scope ctx binds)))))
