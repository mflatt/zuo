#lang zuo/datum

(define make-scope (lambda (name) (string->uninterned-symbol name)))
(define set-add (lambda (ht v) (hash-set ht v #t)))
(define set-remove hash-remove)
(define set-flip (lambda (ht v)
                   (let ([ht2 (hash-remove ht v)])
                     (if (eq? ht ht2)
                         (hash-set ht v #t)
                         ht2))))

(define scope-set=?
  (lambda (sc1 sc2)
    (and (hash-keys-subset? sc1 sc2)
         (hash-keys-subset? sc2 sc1))))

(define empty-prop (hash))
(define prop-add (lambda (prop s) (hash-set prop s 'add)))
(define prop-remove (lambda (prop s) (hash-set prop s 'remove)))
(define prop-flip
  (lambda (prop s)
    (let ([v (hash-ref prop s #f)])
      (cond
        [(not v) (hash-set prop s 'flip)]
        [(eq? v 'flip) (hash-remove prop s)]
        [(eq? v 'add) (hash-set prop s 'remove)]
        [else (hash-set prop s 'add)]))))

(define syntax-tag (string->uninterned-symbol "syntax"))
(define identifier (lambda (id scopes) (opaque syntax-tag (cons id scopes))))
(define lazy-prop-pair (lambda (vec) (opaque syntax-tag vec)))

(define syntax? (lambda (v) (and (opaque-ref syntax-tag v #f) #t)))
(define identifier? (lambda (v) (symbol? (car (opaque-ref syntax-tag v '(#f . #f))))))
(define lazy-prop-pair? (lambda (v) (pair? (car (opaque-ref syntax-tag v '(#f . #f))))))
(define identifier-e (lambda (v) (car (opaque-ref syntax-tag v #f))))
(define identifier-scopes (lambda (v) (cdr (opaque-ref syntax-tag v #f))))
(define syntax-raw-content (lambda (v) (opaque-ref syntax-tag v #f))) ; returns # for non-syntaz

(define datum->syntax
  (letrec ([datum->syntax (lambda (ctx v)
                            (cond
                              [(syntax? v) v]
                              [(symbol? v) (identifier v (identifier-scopes ctx))]
                              [(pair? v) (cons (datum->syntax ctx (car v))
                                               (datum->syntax ctx (cdr v)))]
                              [else v]))])
    datum->syntax))

(define syntax->datum
  (letrec ([syntax->datum (lambda (s)
                            (cond
                              [(identifier? s) (identifier-e s)]
                              [(lazy-prop-pair? s) (syntax->datum (car (syntax-raw-content s)))]
                              [(pair? s) (cons (syntax->datum (car s))
                                               (syntax->datum (cdr s)))]
                              [else s]))])
    syntax->datum))

(define adjust-scope
  (lambda (s scope op prop-op)
    (cond
      [(pair? s) (lazy-prop-pair (cons s (prop-op empty-prop scope)))]
      [else (let* ([c (syntax-raw-content s)])
              (if c
                  (let ([a (car c)])
                    (if (symbol? a)
                        (identifier a (op (cdr c) scope))
                        (lazy-prop-pair (cons (car c)
                                              (prop-op (cdr c) scope)))))
                  s))])))
(define add-scope (lambda (s scope) (adjust-scope s scope set-add prop-add)))
(define remove-scope (lambda (s scope) (adjust-scope s scope set-remove prop-remove)))
(define flip-scope (lambda (s scope) (adjust-scope s scope set-flip prop-flip)))

(define apply-prop
  (lambda (prop s)
    (cond
      [(pair? s) (lazy-prop-pair (cons s prop))]
      [else (foldl (lambda (scope s)
                     (let ([op (hash-ref prop scope #f)])
                       (cond
                         [(eq? op 'add) (add-scope s scope)]
                         [(eq? op 'remove) (remove-scope s scope)]
                         [else (flip-scope s scope)])))
                   s
                   (hash-keys prop))])))

(define syntax-e
  (lambda (s) (let ([c (syntax-raw-content s)])
                (if c
                    (let ([a (car c)])
                      (if (symbol? a)
                          a
                          (let ([prop (cdr c)])
                            (cons (apply-prop prop (car a))
                                  (apply-prop prop (cdr a))))))
                    s))))

(define stx-pair?
  (lambda (p) (or (pair? p) (lazy-prop-pair? p))))

(define stx-car
  (lambda (p) (if (pair? p)
                  (car p)
                  (let ([c (syntax-raw-content p)])
                    (if (and c (pair? (car c)))
                        (apply-prop (cdr c) (car (car c)))
                        (error "stx-car: not a syntax pair" p))))))
(define stx-cdr
  (lambda (p) (if (pair? p)
                  (cdr p)
                  (let ([c (syntax-raw-content p)])
                    (if (and c (pair? (car c)))
                        (apply-prop (cdr c) (cdr (car c)))
                        (error "stx-cdr: not a syntax pair" p))))))
(define stx-list?
  (letrec ([stx-list?
            (lambda (p)
              (cond
                [(null? p) #t]
                [(pair? p) (stx-list? (cdr p))]
                [else (let ([c (syntax-raw-content p)])
                        (and c
                             (let ([pr (car c)])
                               (and (pair? pr) (stx-list? (cdr pr))))))]))])
    stx-list?))

(define stx->list
  (letrec ([stx->list
            (lambda (p)
              (cond
                [(null? p) '()]
                [(pair? p) (let ([r (stx->list (cdr p))])
                             (and r (cons (car p) r)))]
                [else (let ([c (syntax-raw-content p)])
                        (and c
                             (let* ([a (car c)])
                               (and (pair? a)
                                    (let* ([prop (cdr c)]
                                           [r (stx->list (apply-prop prop (cdr a)))])
                                      (and r (cons (apply-prop prop (car a))
                                                   r)))))))]))])
    stx->list))

(define stx-length
  (letrec ([stx-length
            (lambda (p)
              (cond
                [(null? p) 0]
                [(pair? p) (+ 1 (stx-length (cdr p)))]
                [else (let ([c (syntax-raw-content p)])
                        (if c
                            (let ([a (car c)])
                              (if (pair? a)
                                  (+ 1 (stx-length (cdr a)))
                                  0))
                            0))]))])
    stx-length))

(define stx-caar (lambda (p) (stx-car (stx-car p))))
(define stx-cadr (lambda (p) (stx-car (stx-cdr p))))
(define stx-cdar (lambda (p) (stx-cdr (stx-car p))))
(define stx-cddr (lambda (p) (stx-cdr (stx-cdr p))))

(define empty-binds (hash))
(define binds-set-context (lambda (binds ctx) binds))
(define top-binding-syms hash-keys)
(define top-binding-ref hash-ref)

(define add-binding*
  (lambda (binds id binding)
    (let* ([sym (identifier-e id)]
           [sc (identifier-scopes id)]
           [sym-binds (hash-ref binds sym (hash))]
           [k-scope (car (hash-keys sc))] ; relying on deterministic order
           [sc+bs (hash-ref sym-binds k-scope '())]
           [sym-binds (hash-set sym-binds k-scope (cons (cons sc binding) sc+bs))])
      (hash-set binds sym sym-binds))))

(define find-all-matching-bindings
  (lambda (binds id)
    (let* ([sym (identifier-e id)]
           [id-sc (identifier-scopes id)]
           [sym-binds (hash-ref binds sym #f)])
      (if (not sym-binds)
          '()
          (foldl (lambda (scope lst)
                   (foldl (lambda (sc+b lst)
                            (let* ([sc (car sc+b)])
                              (if (hash-keys-subset? sc id-sc)
                                  (cons sc+b lst)
                                  lst)))
                          lst
                          (hash-ref sym-binds scope '())))
                 '()
                 (hash-keys sym-binds))))))

(define check-unambiguous
  (lambda (id max-sc+b candidate-sc+bs)
    (map (lambda (sc+b)
           (unless (hash-keys-subset? (car sc+b)
                                      (car max-sc+b))
             (error "ambiguous" (identifier-e id))))
         candidate-sc+bs)))

(define resolve*
  (lambda (binds id)
    (let* ([candidate-sc+bs (find-all-matching-bindings binds id)])
      (cond
        [(pair? candidate-sc+bs)
         (let* ([max-sc+binding (foldl (lambda (sc+b max-sc+b)
                                         (if (> (hash-count (car max-sc+b))
                                                (hash-count (car sc+b)))
                                             max-sc+b
                                             sc+b))
                                       (car candidate-sc+bs)
                                       (cdr candidate-sc+bs))])
           (check-unambiguous id max-sc+binding candidate-sc+bs)
           (cdr max-sc+binding))]
        [else #f]))))

(define bound-identifier=?
  (lambda (id1 id2)
    (unless (identifier? id1) (error "bound-identifier=?: not an identifier" id1))
    (unless (identifier? id2) (error "bound-identifier=?: not an identifier" id2))
    (and (eq? (identifier-e id1) (identifier-e id2))
         (scope-set=? (identifier-scopes id1)
                      (identifier-scopes id2)))))

(define merge-binds*
  (lambda (binds key m-binds)
    ;; merge bindings from `m-binds` to `binds`:
    (foldl (lambda (sym binds)
             (let* ([sym-ht (hash-ref binds sym (hash))]
                    [m-sym-ht (hash-ref m-binds sym #f)]
                    [new-sym-ht
                     (foldl (lambda (s sym-ht)
                              (hash-set sym-ht
                                        s
                                        (append (hash-ref m-sym-ht s '())
                                                (hash-ref sym-ht s '()))))
                            sym-ht
                            (hash-keys m-sym-ht))])
               (hash-set binds sym new-sym-ht)))
           binds
           (hash-keys m-binds))))

;; called on a binding table that just has the initial imports,
;; extracts an assoictaion list of symbol to bindings
(define extract-initial-binds
  (lambda (binds)
    (foldl (lambda (sym sym+bs)
             (let* ([sym-ht (hash-ref binds sym #f)])
               (foldl (lambda (scope sym+bs)
                        (let ([sc+bs (hash-ref sym-ht scope #f)])
                          (foldl (lambda (sc+b sym+bs)
                                   (cons (cons sym (cdr sc+b))
                                         sym+bs))
                                 sym+bs
                                 sc+bs)))
                      sym+bs
                      (hash-keys sym-ht))))
           '()
           (hash-keys binds))))

(include "../mm-common/free-id-eq.zuo")

(define core-sc (hash 'core #t))

(define make-core-bind
  (lambda (bind)
    (hash 'core (list (cons core-sc bind)))))

(define add-core-binding
  (lambda (binds sym core-bind)
    (hash-set binds sym core-bind)))

(define syntax-quote
  (lambda (v ctx)
    (list 'quote v)))

(define apply-macro
  (lambda (m s ctx state k)
    (let* ([apply-macro
            (lambda (proc ctx state)
              (let* ([new-scope (make-scope "macro")]
                     [s (add-scope s new-scope)]
                     [s (if (= 4 (bitwise-and (procedure-arity-mask proc) 4))
                            (proc s (lambda (a b) (free-id=? state (datum->syntax ctx a) (datum->syntax ctx b))))
                            (proc s))]
                     [s (datum->syntax ctx s)]
                     [s (flip-scope s new-scope)])
                (k s state)))])
      (cond
        [(defined-macro? m) (apply-macro (defined-macro-proc m) ctx state)]
        [else
         (let* ([implementation (macro-implementation m)]
                [proc (car implementation)]
                [key (cadr implementation)]
                [ctx (cadr (cdr implementation))]
                [m-binds (cadr (cddr implementation))])
           (apply-macro proc ctx (merge-binds state key m-binds merge-binds*)))]))))

(define make-module-context
  (lambda (mod-path)
    (let* ([mod-scope (make-scope "module")]
           [ctx (identifier 'module (set-add core-sc mod-scope))])
      ctx)))

(define make-exported-macro
  (lambda (proc ctx binds)
    (let ([mod-scope (ormap (lambda (s)
                              (and (not (eq? s 'core)) s))
                            (hash-keys (identifier-scopes ctx)))])
      (make-macro (list proc mod-scope ctx binds)))))
