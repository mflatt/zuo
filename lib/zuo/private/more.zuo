#lang zuo/private/base

(require "base/and-or.zuo"
         "base/let.zuo"
         "base/define.zuo"
         "list.zuo")

(provide any?
         void?
         boolean?

         equal?
         assoc
         member

         ref

         file-exists?
         directory-exists?
         link-exists?
         
         mkdir*
         rm*

         :error :truncate :must-truncate :append :update :can-update

         string-split)


;; mainly for contracts in the docs:
(define (any? v) #t)
(define (void? v) (eq? v (void)))

(define (boolean? v) (or (eq? v #t) (eq? v #f)))

(define (equal? a b)
  (or (eq? a b)
      (cond
        [(pair? a)
         (and (pair? b)
              (equal? (car a) (car b))
              (equal? (cdr a) (cdr b)))]
        [(string? a) (and (string? b)
                          (string=? a b))]
        [(integer? a) (and (integer? b)
                           (= a b))]
        [(hash? a) (and (hash? b)
                        (= (hash-count a) (hash-count b))
                        (hash-keys-subset? a b)
                        (andmap (lambda (k)
                                  (equal? (hash-ref a k #f)
                                          (hash-ref b k #f)))
                                (hash-keys a)))]
        [else #f])))

(define (assoc k lst)
  (unless (list? lst) (error "assoc: not a list" lst))
  (letrec ([assoc (lambda (lst)
                    (cond
                      [(null? lst) #f]
                      [else
                       (let ([a (car lst)])
                         (unless (pair? a)
                           (error "assoc: non-pair found in list" a))
                         (if (equal? (car a) k)
                             a
                             (assoc (cdr lst))))]))])
    (assoc lst)))

(define (member k lst)
  (unless (list? lst) (error "member: not a list" lst))
  (letrec ([member (lambda (lst)
                     (cond
                       [(null? lst) #f]
                       [else
                        (if (equal? k (car lst))
                            lst
                            (member (cdr lst)))]))])
    (member lst)))

(define ref
  (let ([not-there (string->uninterned-symbol "no")])
    (lambda (ht k)
      (unless (hash? ht) (error "ref: not a hash table" ht))
      (let ([v (hash-ref ht k not-there)])
        (if (eq? v not-there)
            (error "ref: key is not present" k)
            v)))))

(define (file-exists? p)
  (unless (path-string? p) (error "file-exists?: not a path string" p))
  (let ([s (stat p #t)])
    (and s (eq? (ref s 'type) 'file))))

(define (directory-exists? p)
  (unless (path-string? p) (error "directory-exists?: not a path string" p))
  (let ([s (stat p #t)])
    (and s (eq? (ref s 'type) 'dir))))

(define (link-exists? p)
  (unless (path-string? p) (error "link-exists?: not a path string" p))
  (let ([s (stat p #f)])
    (and s (eq? (ref s 'type) 'link))))

(define (mkdir* p)
  (unless (path-string? p) (error "mkdir*: not a path string" p))
  (unless (directory-exists? p)
    (let ([l (split-path p)])
      (when (car l) (mkdir* (car l)))
      (mkdir p))))

(define (rm* p)
  (unless (path-string? p) (error "rm*: not a path string" p))
  (define info (stat p #f))
  (when info
    (define type (ref info 'type))
    (cond
      [(eq? type 'file) (rm p)]
      [(eq? type 'link) (rm p)]
      [else
       (for-each (lambda (e)
                   (rm* (build-path p e)))
                 (ls p))
       (rmdir p)])))

(define :error (hash 'exists 'error))
(define :truncate (hash 'exists 'truncate))
(define :must-truncate (hash 'exists 'must-truncate))
(define :append (hash 'exists 'append))
(define :update (hash 'exists 'update))
(define :can-update (hash 'exists 'can-update))

(define (do-string-split who str sep-str)
  (let* ([sep-len (string-length sep-str)]
         [end (- (string-length str) (string-length sep-str))])
    (let loop ([start 0] [i 0])
      (cond
        [(> i end)
         (list (substring str start (string-length str)))]
        [(and (= (string-ref str i) (string-ref sep-str 0))
              (string=? (substring str i (+ i sep-len)) sep-str))
         (cons (substring str start i)
               (loop (+ i sep-len) (+ i sep-len)))]
        [else (loop start (+ i 1))]))))

(define string-split
  (case-lambda
    [(str sep-str)
     (unless (string? str) (error "string-split: not a string" str))
     (unless (and (string? sep-str)
                  (> (string-length sep-str) 0))
       (error "string-split: not a nonempty string" sep-str))
     (do-string-split "string-split" str sep-str)]
    [(str)
     (unless (string? str) (error "string-split: not a string" str))
     (filter (lambda (s) (> (string-length s) 0))
             (do-string-split "string-items" str " "))]))
