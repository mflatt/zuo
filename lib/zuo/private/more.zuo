#lang zuo/private/base

(require "base/and-or.zuo"
         "base/let.zuo"
         "base/define.zuo"
         "list.zuo")

(provide any?
         void?
         boolean?

         equal?
         assoc
         member

         file-exists?
         directory-exists?
         link-exists?
         
         mkdir*
         rm*
         cp*

         :error :truncate :must-truncate :append :update :can-update

         display
         displayln
         file->string
         display-to-file

         string-split
         string-join

         find-executable-path)


;; mainly for contracts in the docs:
(define (any? v) #t)
(define (void? v) (eq? v (void)))

(define (boolean? v) (or (eq? v #t) (eq? v #f)))

(define (equal? a b)
  (or (eq? a b)
      (cond
        [(pair? a)
         (and (pair? b)
              (equal? (car a) (car b))
              (equal? (cdr a) (cdr b)))]
        [(string? a) (and (string? b)
                          (string=? a b))]
        [(integer? a) (and (integer? b)
                           (= a b))]
        [(hash? a) (and (hash? b)
                        (= (hash-count a) (hash-count b))
                        (hash-keys-subset? a b)
                        (andmap (lambda (k)
                                  (equal? (hash-ref a k #f)
                                          (hash-ref b k #f)))
                                (hash-keys a)))]
        [else #f])))

(define (assoc k lst)
  (unless (list? lst) (arg-error 'assoc "list" lst))
  (letrec ([assoc (lambda (lst)
                    (cond
                      [(null? lst) #f]
                      [else
                       (let ([a (car lst)])
                         (unless (pair? a)
                           (error "assoc: non-pair found in list" a))
                         (if (equal? (car a) k)
                             a
                             (assoc (cdr lst))))]))])
    (assoc lst)))

(define (member k lst)
  (unless (list? lst) (arg-error 'member "list" lst))
  (letrec ([member (lambda (lst)
                     (cond
                       [(null? lst) #f]
                       [else
                        (if (equal? k (car lst))
                            lst
                            (member (cdr lst)))]))])
    (member lst)))

(define (file-exists? p)
  (unless (path-string? p) (arg-error 'file-exists? "path string" p))
  (let ([s (stat p)])
    (and s (eq? (hash-ref s 'type) 'file))))

(define (directory-exists? p)
  (unless (path-string? p) (arg-error 'directory-exists?: "path string" p))
  (let ([s (stat p)])
    (and s (eq? (hash-ref s 'type) 'dir))))

(define (link-exists? p)
  (unless (path-string? p) (arg-error 'link-exists? "path string" p))
  (let ([s (stat p #f)])
    (and s (eq? (hash-ref s 'type) 'link))))

(define (mkdir* p)
  (unless (path-string? p) (arg-error 'mkdir* "path string" p))
  (unless (directory-exists? p)
    (let ([l (split-path p)])
      (when (car l) (mkdir* (car l)))
      (mkdir p))))

(define (rm* p)
  (unless (path-string? p) (arg-error 'rm* "path string" p))
  (define info (stat p #f))
  (when info
    (define type (hash-ref info 'type))
    (cond
      [(eq? type 'file) (rm p)]
      [(eq? type 'link) (rm p)]
      [else
       (for-each (lambda (e)
                   (rm* (build-path p e)))
                 (ls p))
       (rmdir p)])))

(define (cp* src dest)
  (unless (path-string? src) (arg-error 'cp* "path string" src))
  (unless (path-string? dest) (arg-error 'cp* "path string" dest))
  (define info (stat src #f))
  (when info
    (define type (hash-ref info 'type))
    (cond
      [(eq? type 'file) (cp src dest)]
      [(eq? type 'link)
       (when (stat dest #f) (rm dest))
       (ln (readlink src) dest)]
      [else
       (unless (directory-exists? dest) (mkdir dest))
       (for-each (lambda (e)
                   (cp* (build-path src e) (build-path dest e)))
                 (ls src))])))

(define :error (hash 'exists 'error))
(define :truncate (hash 'exists 'truncate))
(define :must-truncate (hash 'exists 'must-truncate))
(define :append (hash 'exists 'append))
(define :update (hash 'exists 'update))
(define :can-update (hash 'exists 'can-update))

(define (display v)
  (fd-write (fd-open-output 'stdout) (~a v)))

(define (displayln v)
  (fd-write (fd-open-output 'stdout) (~a v "\n")))

(define (file->string path)
  (unless (path-string? path) (arg-error 'file->string "path string" path))
  (define fd (fd-open-input path))
  (define content (fd-read fd eof))
  (fd-close fd)
  content)

(define (display-to-file str path [options (hash)])
  (unless (string? str) (arg-error 'display-to-file "string" str))
  (unless (path-string? path) (arg-error 'display-to-file "path string" path))
  (define fd (fd-open-output path options))
  (fd-write fd str)
  (fd-close fd))

(define (do-string-split who str sep-str)
  (let* ([sep-len (string-length sep-str)]
         [end (- (string-length str) (string-length sep-str))])
    (let loop ([start 0] [i 0])
      (cond
        [(> i end)
         (list (substring str start (string-length str)))]
        [(and (= (string-ref str i) (string-ref sep-str 0))
              (string=? (substring str i (+ i sep-len)) sep-str))
         (cons (substring str start i)
               (loop (+ i sep-len) (+ i sep-len)))]
        [else (loop start (+ i 1))]))))

(define (string-split str . args)
  (unless (or (null? args) (null? (cdr args))) (arity-error 'string-split (cons str args)))
  (unless (string? str) (arg-error 'string-split "string" str))
  (cond
    [(null? args)
     (filter (lambda (s) (> (string-length s) 0))
             (do-string-split "string-items" str " "))]
    [else
     (let ([sep-str (car args)])
       (unless (and (string? sep-str)
                    (> (string-length sep-str) 0))
         (arg-error 'string-split "nonempty string" sep-str))
       (do-string-split "string-split" str sep-str))]))

(define (string-join strs [sep " "])
  (unless (and (list? strs) (andmap string? strs))
    (arg-error 'string-join "list of strings" strs))
  (unless (string? sep) (arg-error 'string-join "string" strs))
  (apply ~a (let loop ([strs strs])
              (cond
                [(null? strs) '()]
                [(null? (cdr strs)) strs]
                [else (list* (car strs) sep (loop (cdr strs)))]))))

(define (find-executable-path exe)
  (unless (path-string? exe) (arg-error 'find-executable-path "path string" exe))
  (define windows? (eq? (hash-ref (runtime-env) 'system-type) 'windows))
  (define (try-exe p)
    (or (and (file-exists? p) p)
        (and windows?
             (let ([p (~a p ".exe")])
               (and (file-exists? p) p)))))
  (cond
    [(and (relative-path? exe)
          (not (car (split-path exe))))
     (define PATH (ormap (lambda (p)
                           (and ((if windows? string-ci=? string=?) (car p) "PATH")
                                (cdr p)))
                         (hash-ref (runtime-env) 'env '())))
     (and PATH
          (ormap (lambda (dir)
                   (and (path-string? dir)
                        (try-exe (build-path dir exe))))
                 (string-split PATH (if windows? ";" ":"))))]
    [else (try-exe exe)]))
