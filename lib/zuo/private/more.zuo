#lang zuo/private/base

(require "base/and-or.zuo"
         "base/let.zuo"
         "base/define.zuo"
         "list.zuo")

(provide void?
         boolean?

         equal?
         assoc
         member
         remove
         sort

         call/comp

         file-exists?
         directory-exists?
         link-exists?

         explode-path
         simple-form-path
         find-relative-path
         build-normalized-path
         path-replace-suffix

         mkdir*
         rm*
         cp*

         :error :truncate :must-truncate :append :update :can-update

         display
         displayln
         file->string
         display-to-file

         string<?
         string->integer

         string-split
         string-join
         string-trim

         find-executable-path
         shell)

(define (void? v) (eq? v (void)))

(define (boolean? v) (or (eq? v #t) (eq? v #f)))

(define (equal? a b)
  (or (eq? a b)
      (cond
        [(pair? a)
         (and (pair? b)
              (equal? (car a) (car b))
              (equal? (cdr a) (cdr b)))]
        [(string? a) (and (string? b)
                          (string=? a b))]
        [(integer? a) (and (integer? b)
                           (= a b))]
        [(hash? a) (and (hash? b)
                        (= (hash-count a) (hash-count b))
                        (hash-keys-subset? a b)
                        (andmap (lambda (k)
                                  (equal? (hash-ref a k #f)
                                          (hash-ref b k #f)))
                                (hash-keys a)))]
        [else #f])))

(define (assoc k lst)
  (unless (list? lst) (arg-error 'assoc "list" lst))
  (letrec ([assoc (lambda (lst)
                    (cond
                      [(null? lst) #f]
                      [else
                       (let ([a (car lst)])
                         (unless (pair? a)
                           (error "assoc: non-pair found in list" a))
                         (if (equal? (car a) k)
                             a
                             (assoc (cdr lst))))]))])
    (assoc lst)))

(define (member k lst)
  (unless (list? lst) (arg-error 'member "list" lst))
  (letrec ([member (lambda (lst)
                     (cond
                       [(null? lst) #f]
                       [else
                        (if (equal? k (car lst))
                            lst
                            (member (cdr lst)))]))])
    (member lst)))

(define (remove k lst)
  (unless (list? lst) (arg-error 'remove "list" lst))
  (letrec ([remove (lambda (lst)
                     (cond
                       [(null? lst) '()]
                       [else
                        (if (equal? k (car lst))
                            (cdr lst)
                            (cons (car lst) (remove (cdr lst))))]))])
    (remove lst)))

(define (sort ls less-than?)
  (unless (list? ls) (arg-error 'sort "list" ls))
  (unless (procedure? less-than?) (arg-error 'sort "procedure" less-than?))
  (let sort ([ls ls] [len (length ls)])
    (cond
      [(< len 2) ls]
      [else (let ([half (quotient len 2)])
              (let merge ([a (sort (list-tail ls half) (- len half))]
                          [b (sort (list-tail (reverse ls) (- len half)) half)])
                (cond
                  [(null? a) b]
                  [(null? b) a]
                  [(less-than? (car b) (car a)) (cons (car b) (merge a (cdr b)))]
                  [else (cons (car a) (merge (cdr a) b))])))])))

(define (call/comp proc)
  (unless (procedure? proc) (arg-error 'call/comp "procedure" proc))
  (call/cc (lambda (k)
             (proc (lambda (v)
                     (call/prompt
                      (lambda ()
                        (k v))))))))

(define (file-exists? p)
  (unless (path-string? p) (arg-error 'file-exists? "path string" p))
  (let ([s (stat p)])
    (and s (eq? (hash-ref s 'type) 'file))))

(define (directory-exists? p)
  (unless (path-string? p) (arg-error 'directory-exists?: "path string" p))
  (let ([s (stat p)])
    (and s (eq? (hash-ref s 'type) 'dir))))

(define (link-exists? p)
  (unless (path-string? p) (arg-error 'link-exists? "path string" p))
  (let ([s (stat p #f)])
    (and s (eq? (hash-ref s 'type) 'link))))

(define (explode-path p)
  (unless (path-string? p) (arg-error 'explode-path "path string" p))
  (define l (split-path p))
  (if (not (car l))
      (list (cdr l))
      (append (explode-path (car l)) (list (cdr l)))))

(define (dedot-exploded-path p)
  (reverse
   (let dedot ([p (reverse p)] [ups 0])
     (cond
       [(null? p) (if (= ups 0) '() (cons ".." (dedot '() (- ups 1))))]
       [(equal? (car p) ".") (dedot (cdr p) ups)]
       [(equal? (car p) "..") (dedot (cdr p) (+ ups 1))]
       [(= ups 0) (cons (car p) (dedot (cdr p) 0))]
       [else (dedot (cdr p) (- ups 1))]))))

(define (simple-form-path p)
  (apply build-path (dedot-exploded-path (explode-path p))))

(define (find-relative-path wrt p)
  (unless (path-string? wrt)
    (arg-error 'find-relative-path "path string" wrt))
  (unless (path-string? p)
    (arg-error 'find-relative-path "path string" p))
  (unless (eq? (relative-path? wrt) (relative-path? p))
    (error "find-relative-path: paths are not both relative or both absolute" (list wrt p)))
  (define ps (dedot-exploded-path (explode-path p)))
  (define wrts (dedot-exploded-path (explode-path wrt)))
  (if (or (null? ps) (null? wrts) (equal? (car ps) (car wrts)))
      (let loop ([ps ps] [wrts wrts])
        (cond
          [(null? wrts) (if (null? ps) #f (apply build-path ps))]
          [(null? ps) (apply build-path (map (lambda (p) "..") wrts))]
          [(equal? (car ps) (car wrts)) (loop (cdr ps) (cdr wrts))]
          [else (apply build-path (append (map (lambda (p) "..") wrts) ps))]))
      (apply build-path ps)))

;; Like `build-module-path` in that `.` and `..` is normalized at the
;; start of `path` and as exposed at the end of `base`
(define (build-normalized-path orig-base path)
  (unless (path-string? orig-base) (arg-error 'build-normalized-path "path string" orig-base))
  (unless (path-string? path) (arg-error 'build-normalized-path "path string" path))
  (let loop ([base orig-base] [elems (explode-path path)])
    (cond
      [(null? elems) base]
      [(string=? base ".") (loop (car elems) (cdr elems))]
      [(string=? (car elems) ".") (loop base (cdr elems))]
      [(string=? (car elems) "..")
       (define l (split-path base))
       (loop (car l)
             (cond
               [(not (car l)) (error "build-normalized-path: too many ups" (list orig-base path))]
               [(equal? (cdr l) ".") elems]
               [(equal? (cdr l) "..") (cons ".." elems)]
               [else (cdr elems)]))]
      [else (loop (build-path base (car elems)) (cdr elems))])))

(define (path-replace-suffix path-in suffix)
  (unless (path-string? path-in) (arg-error 'path-replace-suffix "path string" path-in))
  (unless (string? suffix) (arg-error 'path-replace-suffix "string" suffix))
  (define l (split-path path-in))
  (define path (cdr l))
  (define new-path
    (let loop ([i (string-length path)])
      (cond
        [(= i 0) (~a path suffix)]
        [else
         (let ([i (- i 1)])
           (if (= (string-ref path i) 46) ; 46 = (char ".")
               (~a (substring path 0 i) suffix)
               (loop i)))])))
  (if (car l)
      (build-path (car l) new-path)
      new-path))

(define (mkdir* p)
  (unless (path-string? p) (arg-error 'mkdir* "path string" p))
  (unless (directory-exists? p)
    (let ([l (split-path p)])
      (when (car l) (mkdir* (car l)))
      (mkdir p))))

(define (rm* p)
  (unless (path-string? p) (arg-error 'rm* "path string" p))
  (define info (stat p #f))
  (when info
    (define type (hash-ref info 'type))
    (cond
      [(eq? type 'file) (rm p)]
      [(eq? type 'link) (rm p)]
      [else
       (for-each (lambda (e)
                   (rm* (build-path p e)))
                 (ls p))
       (rmdir p)])))

(define (cp* src dest)
  (unless (path-string? src) (arg-error 'cp* "path string" src))
  (unless (path-string? dest) (arg-error 'cp* "path string" dest))
  (define info (stat src #f))
  (when info
    (define type (hash-ref info 'type))
    (cond
      [(eq? type 'file) (cp src dest)]
      [(eq? type 'link)
       (when (stat dest #f) (rm dest))
       (ln (readlink src) dest)]
      [else
       (unless (directory-exists? dest) (mkdir dest))
       (for-each (lambda (e)
                   (cp* (build-path src e) (build-path dest e)))
                 (ls src))])))

(define :error (hash 'exists 'error))
(define :truncate (hash 'exists 'truncate))
(define :must-truncate (hash 'exists 'must-truncate))
(define :append (hash 'exists 'append))
(define :update (hash 'exists 'update))
(define :can-update (hash 'exists 'can-update))

(define (display v)
  (fd-write (fd-open-output 'stdout) (~a v)))

(define (displayln v)
  (fd-write (fd-open-output 'stdout) (~a v "\n")))

(define (file->string path)
  (unless (path-string? path) (arg-error 'file->string "path string" path))
  (define fd (fd-open-input path))
  (define content (fd-read fd eof))
  (fd-close fd)
  content)

(define (display-to-file str path [options (hash)])
  (unless (string? str) (arg-error 'display-to-file "string" str))
  (unless (path-string? path) (arg-error 'display-to-file "path string" path))
  (define fd (fd-open-output path options))
  (fd-write fd str)
  (fd-close fd))

(define (string<? a b)
  (unless (string? a) (arg-error 'string<? "string" a))
  (unless (string? b) (arg-error 'string<? "string" b))
  (let string<? ([i 0])
    (cond
      [(= i (string-length a)) (< i (string-length b))]
      [(= i (string-length b)) #t]
      [(< (string-ref a i) (string-ref b i)) #t]
      [(> (string-ref a i) (string-ref b i)) #f]
      [else (string<? (+ i 1))])))

(define (string->integer s)
  (unless (string? s) (arg-error 'string->integer "string" s))
  (let ([len (string-length s)])
    (and (not (= len 0))
         (let ([neg? (= (string-ref s 0) 45)]) ; 45 = (char "-")
           (and (not (and neg? (= len 1)))
                (let string->integer ([n 0] [i (if neg? 1 0)])
                  (cond
                    [(= i (string-length s))
                     (if neg? (- n) n)]
                    [else
                     (let ([c (string-ref s i)])
                       (cond
                         [(and (>= c 48) (<= c 57))
                          (let ([n (+ (* n 10) (- c 48))])
                            (if (< n 0)
                                ;; overflow has one edge care where it's ok
                                (and neg? (= (+ i 1) (string-length s)) (= n -9223372036854775808) n)
                                (string->integer n (+ i 1))))]
                         [else #f]))])))))))

(define (do-string-split who str sep-str)
  (let* ([sep-len (string-length sep-str)]
         [end (- (string-length str) sep-len)])
    (let loop ([start 0] [i 0])
      (cond
        [(> i end)
         (list (substring str start (string-length str)))]
        [(and (= (string-ref str i) (string-ref sep-str 0))
              (string=? (substring str i (+ i sep-len)) sep-str))
         (cons (substring str start i)
               (loop (+ i sep-len) (+ i sep-len)))]
        [else (loop start (+ i 1))]))))

(define (string-split str . args)
  (unless (or (null? args) (null? (cdr args))) (arity-error 'string-split (cons str args)))
  (unless (string? str) (arg-error 'string-split "string" str))
  (cond
    [(null? args)
     (filter (lambda (s) (> (string-length s) 0))
             (do-string-split "string-items" str " "))]
    [else
     (let ([sep-str (car args)])
       (unless (and (string? sep-str)
                    (> (string-length sep-str) 0))
         (arg-error 'string-split "nonempty string" sep-str))
       (do-string-split "string-split" str sep-str))]))

(define (string-join strs [sep " "])
  (unless (and (list? strs) (andmap string? strs))
    (arg-error 'string-join "list of strings" strs))
  (unless (string? sep) (arg-error 'string-join "string" strs))
  (apply ~a (let loop ([strs strs])
              (cond
                [(null? strs) '()]
                [(null? (cdr strs)) strs]
                [else (list* (car strs) sep (loop (cdr strs)))]))))

(define (string-trim str [sep-str " "])
  (unless (string? str) (arg-error 'string-split "string" str))
  (unless (and (string? sep-str) (> (string-length sep-str) 0))
    (arg-error 'string-split "nonempty string" sep-str))
  (let* ([len (string-length str)]
         [sep-len (string-length sep-str)]
         [match-at? (lambda (i)
                      (and (= (string-ref str i) (string-ref sep-str 0))
                           (string=? (substring str i (+ i sep-len)) sep-str)))])
    (if (< len sep-len)
        str
        (let ([start (let loop ([i 0])
                       (cond
                         [(> i (- len sep-len)) i]
                         [(match-at? i) (loop (+ i sep-len))]
                         [else i]))]
              [end (let loop ([i len])
                     (cond
                       [(< i sep-len) i]
                       [(match-at? (- i sep-len)) (loop (- i sep-len))]
                       [else i]))])
          (if (> end start)
              (substring str start end)
              "")))))

(define (find-executable-path exe)
  (unless (path-string? exe) (arg-error 'find-executable-path "path string" exe))
  (define windows? (eq? (hash-ref (runtime-env) 'system-type) 'windows))
  (define (try-exe p)
    (or (and (file-exists? p) p)
        (and windows?
             (let ([p (~a p ".exe")])
               (and (file-exists? p) p)))))
  (cond
    [(and (relative-path? exe)
          (not (car (split-path exe))))
     (define PATH (ormap (lambda (p)
                           (and ((if windows? string-ci=? string=?) (car p) "PATH")
                                (cdr p)))
                         (hash-ref (runtime-env) 'env '())))
     (and PATH
          (ormap (lambda (dir)
                   (and (path-string? dir)
                        (try-exe (build-path dir exe))))
                 (cons (hash-ref (runtime-env) 'dir)
                       (string-split PATH (if windows? ";" ":")))))]
    [else (try-exe exe)]))

(define (shell command [options (hash)])
  (cond
    [(eq? (hash-ref (runtime-env) 'system-type) 'unix)
     (apply process (append '("/bin/sh" "-c") (list command options)))]
    [else
     (let ([cmd (build-path (hash-ref (runtime-env) 'sys-dir) "cmd.exe")])
       (process cmd (~a cmd " /c \"" command "\"") (hash-set options 'exact? #t)))]))
