#lang zuo/private/defmacromod

(require "defmacromod/and-or.zuo"
         "defmacromod/define.zuo"
         "list.zuo")

(provide any?
         void?
         boolean?

         equal?

         ref

         file-exists?
         directory-exists?
         link-exists?
         
         mkdir*)

;; mainly for contracts in the docs:
(define (any? v) #t)
(define (void? v) (eq? v (void)))

(define (boolean? v) (or (eq? v #t) (eq? v #f)))

(define (equal? a b)
  (or (eq? a b)
      (cond
        [(pair? a)
         (and (pair? b)
              (equal? (car a) (car b))
              (equal? (cdr a) (cdr b)))]
        [(string? a) (and (string? b)
                          (string=? a b))]
        [(integer? a) (and (integer? b)
                           (= a b))]
        [(hash? a) (and (hash? b)
                        (= (hash-count a) (hash-count b))
                        (hash-keys-subset? a b)
                        (andmap (lambda (k)
                                  (equal? (hash-ref a k #f)
                                          (hash-ref b k #f)))
                                (hash-keys a)))]
        [else #f])))

(define ref
  (let ([not-there (string->uninterned-symbol "no")])
    (lambda (ht k)
      (let ([v (hash-ref ht k not-there)])
        (if (eq? v not-there)
            (error "ref: key is not present" k)
            v)))))

(define (file-exists? p)
  (let ([s (stat p #t)])
    (and s (eq? (ref s 'type) 'file))))

(define (directory-exists? p)
  (let ([s (stat p #t)])
    (and s (eq? (ref s 'type) 'dir))))

(define (link-exists? p)
  (let ([s (stat p #f)])
    (and s (eq? (ref s 'type) 'link))))

(define (mkdir* p)
  (unless (directory-exists? p)
    (let ([l (split-path p)])
      (when (car l) (mkdir* (car l)))
      (mkdir p))))
