#lang zuo/datum

;; The `read-and-eval` entry point for a language using the expander

(define (make-read-and-eval make-initial-state)
  (lambda (str start mod-path)
    (let* ([es (read-from-string-all str start)]
           [ctx (make-module-context mod-path)]
           [es (map (lambda (e) (datum->syntax ctx e)) es)]
           [parse (make-parse ctx mod-path)]
           [initial-state (make-initial-state ctx)]
           [initial-provides (hash)]
           [es+state+provides (expand-sequence es initial-state initial-provides mod-path ctx parse)]
           [es (car es+state+provides)]
           [state (cadr es+state+provides)]
           [binds (state-binds state)]
           [provides (cadr (cdr es+state+provides))]
           [outs (foldl (lambda (as-sym outs)
                          (let* ([id (hash-ref provides as-sym #f)]
                                 [bind (resolve* (state-binds state) id #f)])
                            (unless bind
                              (syntax-error "provided identifier not bound" id))
                            (hash-set outs as-sym (export-bind bind ctx binds))))
                        (hash)
                        (hash-keys provides))]
           [print-result (lambda (v)
                           (unless (eq? v (void))
                             (alert (~v v))))]
           [add-print (lambda (s) (list print-result s))])
      (eval (cons 'begin (cons '(void) (map (lambda (e) (add-print (parse e state))) es))))
      (hash 'macromod-provides outs
            merge-bindings-export-key (make-export-merge-binds ctx binds)))))

(hash
 ;; makes `#lang zuo/private/macromod work:
 'read-and-eval (make-read-and-eval (lambda (ctx)
                                      (make-state (binds-create top-provides ctx)
                                                  (initial-nominals language-mod-path top-provides))))
 ;; makes `(require zuo/private/macromod)` work:
 'macromod-provides top-provides
 ;; for making a new `#lang` with some initial imports:
 'make-read-and-eval-with-initial-imports-from
 (lambda (mod-path)
   (let* ([mod (dynamic-require mod-path)]
          [provides (hash-ref mod 'macromod-provides #f)]
          [m-binds (hash-ref mod merge-bindings-export-key #f)])
     (unless provides 
       (syntax-error "not a compatible module for initial imports" mod-path))
     (make-read-and-eval
      (lambda (ctx)
        (make-state (merge-binds* (binds-create provides ctx) m-binds)
                    (initial-nominals mod-path provides)))))))
