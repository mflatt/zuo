#lang zuo/datum

;; Helpers for "parse.zuo" that depends on the implementation of
;; syntax (i.e., syntax objects vs. plain S-expressions)

(define stx-caar (lambda (p) (stx-car (stx-car p))))
(define stx-cadr (lambda (p) (stx-car (stx-cdr p))))
(define stx-cdar (lambda (p) (stx-cdr (stx-car p))))
(define stx-cddr (lambda (p) (stx-cdr (stx-cdr p))))

(define maybe-begin
  (lambda (d)
    (if (null? d)
        (car d)
        (cons 'begin d))))

(define name-lambda
  (lambda (form id)
    (if (and (pair? form)
             (eq? (car form) 'lambda))
        ;; `zuo/kernel` recognizes this pattern to name the form
        (list 'lambda (cadr form) (symbol->string (identifier-e id)) (cadr (cdr form)))
        form)))

(define syntax-error
  (lambda (msg s) (error (~a msg ": " (~s (syntax->datum s))))))

(define bad-syntax
  (lambda (s) (syntax-error "bad syntax" s)))

(define duplicate-identifier
  (lambda (id s) (error "duplicate identifier:" (identifier-e id) (syntax->datum s))))

(define id-sym-eq?
  (lambda (id sym)
    (and (identifier? id)
         (eq? (identifier-e id) sym))))

(define unwrap-mod-path
  (lambda (mod-path)
    (if (identifier? mod-path)
        (identifier-e mod-path)
        mod-path)))

(define add-binding
  (lambda (state id binding)
    (state-set-binds state (add-binding* (state-binds state) id binding))))

(define resolve
  (lambda (state id)
    (let* ([bind (resolve* (state-binds state) id)]
           [bind (unwrap-specific bind)])
      (if (initial-import? bind)
          (initial-import-bind bind)
          bind))))

(define parse*
  (lambda (parse es state)
    (letrec ([parse* (lambda (es)
                       (cond
                         [(null? es) '()]
                         [else (cons (parse (stx-car es) state)
                                     (parse* (stx-cdr es)))]))])
      (parse* es))))
