#lang zuo/datum

;; The state of expansion is a combinion of bindings and "nominals",
;; which is information about `require`s that is used to implement
;; `(provide (all-from-out ....))`

(define make-state (lambda (binds nominals) (cons binds (cons (hash) nominals))))
(define state-binds car)
(define state-merged cadr)
(define state-nominals cddr)
(define state-set-binds (lambda (state binds) (cons binds (cdr state))))
(define state-set-merged (lambda (state merged) (cons (car state) (cons merged (cddr state)))))
(define state-set-nominals (lambda (state nominals) (cons (car state) (cons (cadr state) nominals))))

(define call-with-nominal
  (lambda (state mod-path default-ids k)
    (let* ([fronted
            (letrec ([assoc-to-front
                      (lambda (l)
                        (cond
                          [(null? l) (list (cons mod-path default-ids))]
                          [(mod-path=? mod-path (caar l)) l]
                          [else (let ([new-l (assoc-to-front (cdr l))])
                                  (cons (car new-l) (cons (car l) (cdr new-l))))]))])
              (assoc-to-front (state-nominals state)))])
      (k (cdar fronted)
         (lambda (new-sym+bs)
           (let* ([new-noms (cons (cons (caar fronted) new-sym+bs)
                                  (cdr fronted))])
             (state-set-nominals state new-noms)))))))

(define init-nominal
  (lambda (state mod-path)
    (call-with-nominal state mod-path '()
                       (lambda (sym+binds install)
                         (install sym+binds)))))

(define record-nominal
  (lambda (state mod-path sym bind)
    (call-with-nominal state mod-path '()
                       (lambda (sym+binds install)
                         (install (cons (cons sym bind) sym+binds))))))

(define lookup-nominal
  (lambda (state mod-path)
    (call-with-nominal state mod-path #f
                       (lambda (sym+binds install)
                         sym+binds))))

;; in case `all-from-out` is used on the initial import,
;; adds all the current ids in `binds` as nominally imported
(define initial-nominals
  (lambda (mod-path sym+bs)
    (list (cons mod-path sym+bs))))

(define merge-binds
  (lambda (state key m-binds merge-binds*)
    (let* ([merged (state-merged state)])
      (cond
        [(hash-ref merged key #f)
         ;; already merged
         state]
        [else
         (let* ([merged (hash-set merged key #t)]
                [binds (state-binds state)]
                [new-binds (merge-binds* binds key m-binds)])
           (state-set-binds (state-set-merged state merged) new-binds))]))))
