#lang zuo/datum

;; The state of expansion is a combinion of bindings and "nominals",
;; which is information about `require`s that is used to implement
;; `(provide (all-from-out ....))`

(define make-state cons)
(define state-binds car)
(define state-nominals cdr)
(define (state-set-binds state binds) (cons binds (cdr state)))
(define (state-set-nominals state nominals) (cons (car state) nominals))

;; helper to lookup or update nominals:
(define (call-with-nominal state mod-path default-ids k)
  (let* ([fronted
          (letrec ([assoc-to-front
                    (lambda (l)
                      (cond
                        [(null? l) (list (cons mod-path default-ids))]
                        [(mod-path=? mod-path (caar l)) l]
                        [else (let ([new-l (assoc-to-front (cdr l))])
                                (cons (car new-l) (cons (car l) (cdr new-l))))]))])
            (assoc-to-front (state-nominals state)))])
    (k (cdar fronted)
       (lambda (new-sym+bs)
         (let* ([new-noms (cons (cons (caar fronted) new-sym+bs)
                                (cdr fronted))])
           (state-set-nominals state new-noms))))))

(define (init-nominal state mod-path)
  (call-with-nominal state mod-path '()
                     (lambda (sym+binds install)
                       (install sym+binds))))

(define (record-nominal state mod-path sym bind)
  (call-with-nominal state mod-path '()
                     (lambda (sym+binds install)
                       (install (cons (cons sym bind) sym+binds)))))

(define (lookup-nominal state mod-path)
  (call-with-nominal state mod-path #f
                     (lambda (sym+binds install)
                       sym+binds)))

;; in case `all-from-out` is used on the initial import,
;; adds all the current ids in `binds` as nominally imported
(define (initial-nominals mod-path sym+bs)
  (list (cons mod-path sym+bs)))
