#lang zuo/datum

;; Creation of the initial bindings and managing imports/exports

;; A binding can be any non-pair value...

(define make-core-initial-bind
  (lambda (bind)
    (as-specific (make-initial-import bind))))

(define kernel-provides
  (let* ([ht (kernel-env)])
    (foldl (lambda (sym provides)
             (cond
               [(or (eq? sym 'eval)
                    (eq? sym 'dynamic-require))
                ;; skip things related to the `zuo/kernel` evaluator
                provides]
               [else
                (hash-set provides sym (make-core-initial-bind (hash-ref ht sym #f)))]))
           (hash)
           (hash-keys ht))))

(define top-form-provides
  (foldl (lambda (sym provides)
           (hash-set provides sym (make-core-initial-bind (make-core-form sym))))
         kernel-provides
         '(lambda let letrec quote if begin
                  define define-syntax require provide
                  quote-syntax
                  include)))

(define top-provides
  (let* ([provides top-form-provides]
         [add (lambda (provides name val) (hash-set provides name (make-core-initial-bind val)))]
         [provides (add provides 'identifier? identifier?)]
         [provides (add provides 'syntax-e syntax-e)]
         [provides (add provides 'syntax->datum syntax->datum)]
         [provides (add provides 'datum->syntax datum->syntax)]
         [provides (add provides 'bound-identifier=? bound-identifier=?)])
    provides))

;; convert a local binding into one suitable to import
(define export-bind
  (lambda (bind ctx binds)
    (let* ([label (and (specific? bind)
                       (specific-label bind))]
           [bind (unwrap-specific bind)]
           [bind (if (initial-import? bind)
                     (initial-import-bind bind)
                     bind)]
           [bind (cond
                   [(defined? bind)
                    (make-local-variable (variable-var bind))]
                   [(defined-macro? bind)
                    (make-exported-macro (defined-macro-proc bind) ctx binds)]
                   [else bind])])
      (if label
          (make-specific (cons bind label))
          bind))))

(define initial-import
  (lambda (bind)
    (let* ([label (and (specific? bind)
                       (specific-label bind))]
           [bind (unwrap-specific bind)]
           [bind (make-initial-import bind)])
      (if label
          (make-specific (cons bind label))
          bind))))

;; in case `all-from-out` is used on the initial import,
;; adds all the current ids in `binds` as nominally imported
(define initial-nominals
  (lambda (mod-path provides)
    (list (cons mod-path
                (map (lambda (sym) (cons sym (hash-ref provides sym #f)))
                     (hash-keys provides))))))
