#lang zuo/datum

;; This is the main parser/expander, to be included in a context that
;; plugs in the implementation of syntax objects and macros (so,
;; hygienic or not)

;; The `expand-...` functions handle the top-level sequence, while
;; `parse-...` is for expressions

(include "parse-lib.zuo")

(define expand-define
  (lambda (s state k)
    (unless (and (list? s) (= 3 (length s)) (identifier? (cadr s)))
      (bad-syntax s))
    (let* ([id (cadr s)]
           [id-bind (resolve state id)])
      (when (or (defined? id-bind)
                (defined-macro? id-bind))
        (syntax-error "duplicate definition" id))
      (let* ([sym (syntax-e id)]
             [def-id (gensym sym)]
             [var (variable sym)]
             [new-state (add-binding state id (as-specific (make-defined var)))]
             ;; construct an expression with the var inlined:
             [new-s (list variable-set! var (list name-lambda (cadr (cdr s)) id))])
        (k new-s new-state)))))

(define expand-define-syntax
  (lambda (s state parse)
    (unless (and (list? s) (= 3 (length s)) (identifier? (cadr s)))
      (bad-syntax s))
    (let* ([id (cadr s)]
           [id-bind (resolve state id)])
      (when (or (defined? id-bind)
                (defined-macro? id-bind))
        (syntax-error "duplicate definition" id))
      (let* ([e (parse (cadr (cdr s)) state)]
             [proc (eval (name-lambda e id))])
        (add-binding state id (as-specific (make-defined-macro proc)))))))

(define expand-provide
  (lambda (s state provides mod-path)
    (unless (list? s) (bad-syntax s))
    (foldl (lambda (p provides)
             (let* ([add-provide (lambda (provides id as-sym)
                                   (let* ([old-id (hash-ref provides as-sym #f)])
                                     (when (and old-id
                                                (not (free-id=? (state-binds state) old-id id)))
                                       (syntax-error "already provided as different binding" as-sym))
                                     (hash-set provides as-sym id)))]
                    [bad-provide-form (lambda () (syntax-error "bad provide clause" p))])
               (cond
                 [(identifier? p) (add-provide provides p (syntax-e p))]
                 [(pair? p)
                  (unless (list? p) (bad-provide-form))
                  (let ([form (car p)])
                    (cond
                      [(id-sym-eq? form 'rename-out)
                       (foldl (lambda (rn provides)
                                (unless (and (list? rn) (= 2 (length rn))
                                             (identifier? (car rn)) (identifier? (cadr rn)))
                                  (bad-provide-form))
                                (add-provide provides (car rn) (syntax-e (cadr rn))))
                              provides
                              (cdr p))]
                      [(id-sym-eq? form 'all-from-out)
                       (foldl (lambda (req-path provides)
                                (let* ([prov-ctx (car s)]
                                       [sym+binds (lookup-nominal state (unwrap-mod-path req-path))])
                                  (unless sym+binds (syntax-error "module not required" req-path))
                                  (foldl (lambda (sym+bind provides)
                                           (let* ([sym (car sym+bind)]
                                                  [id (datum->syntax prov-ctx sym)]
                                                  [bind (resolve* (state-binds state) id)])
                                             (cond
                                               [(not (specific=? bind (cdr sym+bind)))
                                                ;; shadowed by definition or other import
                                                provides]
                                               [else
                                                (add-provide provides id sym)])))
                                         provides
                                         sym+binds)))
                              provides
                              (cdr p))]
                      [else (bad-provide-form)]))]
                 [else (bad-provide-form)])))
           provides
           (cdr s))))

(define expand-require
  (lambda (s state mod-path)
    (let* ([check-renames
            ;; syntax check on renaming clauses `ns`
            (lambda (r ns id-ok?)
              (map (lambda (n) (unless (or (and id-ok?
                                                (identifier? n))
                                           (and (list? n)
                                                (= 2 (length n))
                                                (identifier? (car n))
                                                (identifier? (cadr n))))
                                 (bad-syntax r)))
                   ns))]
           [make-rename-filter
            ;; used to apply `ns` renaming clauses to an imported identifier
            (lambda (ns only?)
              (lambda (sym)
                (letrec ([loop (lambda (ns)
                                 (cond
                                   [(null? ns) (if only? #f sym)]
                                   [(id-sym-eq? (car ns) sym) sym]
                                   [(and (pair? (car ns))
                                         (id-sym-eq? (caar ns) sym))
                                    (syntax-e (cadr (car ns)))]
                                   [else (loop (cdr ns))]))])
                  (loop ns))))]
           [make-provides-checker
            ;; used to check whether set of provided is consistent with `ns`
            (lambda (ns)
              (lambda (provides)
                (map (lambda (n)
                       (let ([id (if (pair? n) (car n) n)])
                         (unless (hash-ref provides (syntax-e id) #f)
                           (syntax-error "identifier is not in required set" id))))
                     ns)))])
      ;; parse each `require` clause `r:
      (foldl (lambda (r state)
               (let* ([req-ctx (car s)]
                      [req-path+filter+check
                       (cond
                         [(string? r) (list r (lambda (sym) sym) void)]
                         [(identifier? r) (list (syntax-e r) (lambda (sym) sym) void)]
                         [(pair? r)
                          (unless (and (list? r) (pair? (cdr r))) (bad-syntax r))
                          (let* ([ns (cddr r)])
                            (cond
                              [(id-sym-eq? (car r) 'only-in)
                               (check-renames r ns #t)
                               (list (cadr r) (make-rename-filter ns #t) (make-provides-checker ns))]
                              [(id-sym-eq? (car r) 'rename-in)
                               (check-renames r ns #f)
                               (list (cadr r) (make-rename-filter ns #f) (make-provides-checker ns))]
                              [else (bad-syntax r)]))]
                         [else (bad-syntax r)])]
                      [req-path (car req-path+filter+check)]
                      [filter (cadr req-path+filter+check)]
                      [check (cadr (cdr req-path+filter+check))]
                      [in-mod-path (module-path-join req-path mod-path)]
                      [mod (dynamic-require in-mod-path)]
                      [provides (hash-ref mod 'macromod-provides #f)]
                      [state (init-nominal state (unwrap-mod-path req-path))])
                 (unless provides (syntax-error "not a compatible module" r))
                 (check provides)
                 ;; add each provided binding (except as filtered)
                 (foldl (lambda (sym state)
                          (let* ([as-sym (filter sym)])
                            (cond
                              [(not as-sym) state]
                              [else
                               ;; check whether it's bound already
                               (let* ([as-id (datum->syntax req-ctx as-sym)]
                                      [current-bind (resolve* (state-binds state) as-id)]
                                      [req-bind (hash-ref provides sym #f)]
                                      [add-binding/record-nominal
                                       (lambda ()
                                         (let* ([state (add-binding state as-id req-bind)])
                                           (record-nominal state (unwrap-mod-path req-path) as-sym req-bind)))])
                                 (cond
                                   [(not current-bind)
                                    ;; not already bound, so import is ok
                                    (add-binding/record-nominal)]
                                   [(initial-import? (unwrap-specific current-bind))
                                    ;; `require` can shadow an initial import
                                    (add-binding/record-nominal)]
                                   [(specific=? current-bind req-bind)
                                    ;; re-import of same variable or primitive, also ok
                                    state]
                                   [(or (defined? current-bind)
                                        (defined-macro? current-bind))
                                    ;; definition shadows import
                                    state]
                                   [else
                                    (syntax-error "identifier is already imported" as-id)]))])))
                        state
                        (hash-keys provides))))
             state
             (cdr s)))))

(define expand-include
  (lambda (s mod-path)
    (unless (and (list? s) (= 2 (length s)))
      (bad-syntax s))
    (let* ([include-ctx (car s)]
           [in-mod-path (unwrap-mod-path (cadr s))]
           [in-mod-path (module-path-join in-mod-path mod-path)]
           [mod (dynamic-require in-mod-path)]
           [datums (hash-ref mod 'datums #f)])
      (unless datums (error "not an includable module" in-mod-path))
      (map (lambda (e) (datum->syntax include-ctx e)) datums))))

;; expand top-level forms and gather imports and definitions
(define expand-top-sequence
  (lambda (es state mod-path ctx parse)
    (letrec ([expand-top
              (lambda (es accum state provides)
                (cond
                  [(null? es) (list (reverse accum) state provides)]
                  [else
                   (let* ([s (car es)])
                     (cond
                       [(pair? s)
                        (let* ([rator (car s)]
                               [bind (and (identifier? rator)
                                          (resolve state rator))])
                          (cond
                            [(macro? bind)
                             (apply-macro bind s ctx (state-binds state)
                                          (lambda (new-s new-binds)
                                            (let ([new-state (state-set-binds state new-binds)])
                                              (expand-top (cons new-s (cdr es)) accum new-state provides))))]
                            [(core-form? bind)
                             (let ([bind (form-id bind)])
                               (cond
                                 [(eq? bind 'begin)
                                  (unless (list? s) (bad-syntax s))
                                  (expand-top (append (cdr s) (cdr es)) accum state provides)]
                                 [(eq? bind 'define)
                                  (expand-define s
                                                 state
                                                 (lambda (new-s new-state)
                                                   (expand-top (cdr es) (cons new-s accum) new-state provides)))]
                                 [(eq? bind 'define-syntax)
                                  (let ([new-state (expand-define-syntax s state parse)])
                                    (expand-top (cdr es) accum new-state provides))]
                                 [(eq? bind 'provide)
                                  (let ([new-provides (expand-provide s state provides mod-path)])
                                    (expand-top (cdr es) accum state new-provides))]
                                 [(eq? bind 'require)
                                  (let ([new-state (expand-require s state mod-path)])
                                    (expand-top (cdr es) accum new-state provides))]
                                 [(eq? bind 'include)
                                  (let ([new-es (append (expand-include s mod-path) (cdr es))])
                                    (expand-top new-es accum state provides))]
                                 [else
                                  (expand-top (cdr es) (cons s accum) state provides)]))]
                            [else (expand-top (cdr es) (cons s accum) state provides)]))]
                       [else (expand-top (cdr es) (cons s accum) state provides)]))]))])
      (expand-top es '() state (hash)))))

(define parse-lambda
  (lambda (s state parse)
    (unless (>= (length s) 3) (bad-syntax s))
    (let* ([formals (cadr s)]
           [new-formals (letrec ([reformal (lambda (f seen)
                                             (cond
                                               [(null? f) '()]
                                               [(identifier? f)
                                                (when (ormap (lambda (sn) (bound-identifier=? f sn)) seen)
                                                  (duplicate-identifier f s))
                                                (gensym (syntax-e f))]
                                               [(pair? f)
                                                (let* ([a (car f)])
                                                  (unless (identifier? a) (bad-syntax s))
                                                  (cons (reformal a seen)
                                                        (reformal (cdr f) (cons a seen))))]
                                               [else (bad-syntax s)]))])
                          (reformal formals '()))]
           [new-scope (make-scope "lambda")]
           [state (letrec ([add-formals (lambda (state formals new-formals)
                                          (cond
                                            [(identifier? formals)
                                             (let* ([id (add-scope formals new-scope)])
                                               (add-binding state id (make-local new-formals)))]
                                            [(pair? new-formals)
                                             (add-formals (add-formals state (cdr formals) (cdr new-formals))
                                                          (car formals)
                                                          (car new-formals))]
                                            [else state]))])
                    (add-formals state formals new-formals))])
      (list 'lambda new-formals
             (maybe-begin (map (lambda (e) (parse e state)) (add-scope (cddr s) new-scope)))))))

(define parse-let
  (lambda (s state parse)
    (unless (>= (length s) 3) (bad-syntax s))
    (let* ([cls (cadr s)]
           [orig-state state]
           [new-scope (make-scope "let")])
      (unless (list? cls) (bad-syntax s))
      (letrec ([parse-clauses
                (lambda (cls new-cls state seen)
                  (cond
                    [(null? cls)
                     (nest-bindings (reverse new-cls)
                                    (maybe-begin (map (lambda (s) (parse s state)) (add-scope (cddr s) new-scope))))]
                    [else
                     (let* ([cl (car cls)])
                       (unless (and (list? cl) (= 2 (length cl))) (bad-syntax s))
                       (let* ([id (car cl)])
                         (unless (identifier? id) (bad-syntax s))
                         (when (ormap (lambda (sn) (bound-identifier=? id sn)) seen)
                           (duplicate-identifier id s))
                         (let* ([new-id (gensym (syntax-e id))])
                           (parse-clauses (cdr cls)
                                          (cons (list new-id (name-lambda
                                                              (parse (cadr cl) orig-state)
                                                              id))
                                                new-cls)
                                          (add-binding state (add-scope id new-scope) (make-local new-id))
                                          (cons id seen)))))]))])
        (parse-clauses cls '() state '())))))

(define parse-letrec
  (lambda (s state parse)
    (unless (>= (length s) 3) (bad-syntax s))
    (let* ([cls (cadr s)]
           [orig-state state]
           [new-scope (make-scope "letrec")])
      (unless (list? cls) (bad-syntax s))
      ;; use mutable variables to tie knots
      (letrec ([bind-all (lambda (x-cls new-ids state seen)
                           (cond
                             [(null? x-cls)
                              (nest-bindings
                               (map (lambda (new-id)
                                      (list new-id (list variable (list 'quote new-id))))
                                    new-ids)
                               (list 'begin
                                     (cons 'begin (map2 (lambda (cl new-id)
                                                          (list variable-set! (car new-ids)
                                                                (name-lambda
                                                                 (let ([rhs (cadr (car cls))])
                                                                   (parse (add-scope rhs new-scope) state))
                                                                 (caar cls))))
                                                        cls
                                                        (reverse new-ids)))
                                     (maybe-begin (map (lambda (s) (parse s state)) (add-scope (cddr s) new-scope)))))]
                             [else
                              (let* ([cl (car x-cls)])
                                (unless (and (list? cl) (= 2 (length cl))) (bad-syntax s))
                                (let* ([id (car cl)])
                                  (unless (identifier? id) (bad-syntax s))
                                  (when (ormap (lambda (sn) (bound-identifier=? id sn)) seen)
                                    (duplicate-identifier id s))
                                  (let ([new-id (gensym (syntax-e id))])
                                    (bind-all (cdr x-cls)
                                              (cons new-id new-ids)
                                              (add-binding state (add-scope id new-scope) (make-local-variable new-id))
                                              (cons id seen)))))]))])
        (bind-all cls '() state '())))))

(define parse-let/cc
  (lambda (s state parse)
    (unless (and (>= (length s) 3) (identifier? (cadr s))) (bad-syntax s))
    (let* ([id (cadr s)]
           [new-id (gensym (syntax-e id))]
           [new-scope (make-scope "letcc")]
           [state (add-binding state (add-scope id new-scope) (make-local new-id))])
      (list 'let/cc new-id
            (maybe-begin (map (lambda (s) (parse s state)) (add-scope (cddr s) new-scope)))))))

(define make-parse
  (lambda (ctx)
    (letrec ([parse
              (lambda (s state)
                (cond
                  [(pair? s)
                   (let* ([rator (car s)]
                          [bind (and (identifier? rator)
                                     (resolve state rator))])
                     (cond
                       [(macro? bind)
                        (apply-macro bind s ctx (state-binds state)
                                     (lambda (new-s new-binds)
                                       (parse new-s (state-set-binds state new-binds))))]
                       [(core-form? bind)
                        (unless (list? s) (bad-syntax s))
                        (let ([bind (form-id bind)])
                          (cond
                            [(eq? bind 'lambda)
                             (parse-lambda s state parse)]
                            [(eq? bind 'let)
                             (parse-let s state parse)]
                            [(eq? bind 'letrec)
                             (parse-letrec s state parse)]
                            [(eq? bind 'let/cc)
                             (parse-let/cc s state parse)]
                            [(eq? bind 'quote)
                             (unless (= 2 (length s)) (bad-syntax s))
                             (list 'quote (syntax->datum (cadr s)))]
                            [(eq? bind 'quote-syntax)
                             (unless (= 2 (length s)) (bad-syntax s))
                             (syntax-quote (cadr s) ctx)]
                            [(eq? bind 'if)
                             (unless (= 4 (length s)) (bad-syntax s))
                             (list 'if
                                   (parse (cadr s) state)
                                   (parse (cadr (cdr s)) state)
                                   (parse (cadr (cddr s)) state))]
                            [(eq? bind 'begin)
                             (unless (pair? (cdr s)) (bad-syntax s))
                             (let ([es (map (lambda (e) (parse e state)) (cdr s))])
                               (if (null? (cdr es))
                                   (car es)
                                   (cons 'begin es)))]
                            [else
                             (map (lambda (e) (parse e state)) s)]))]
                       [(eq? rator name-lambda) ; form created by `define` to propagate name
                        (name-lambda (parse (cadr s) state) (cadr (cdr s)))]
                       [else (map (lambda (e) (parse e state)) s)]))]
                  [(identifier? s)
                   (let* ([bind (resolve state s)])
                     (cond
                       [(core-form? bind) (bad-syntax s)]
                       [(local? bind) (local-id bind)]
                       [(variable? bind) (list variable-ref (variable-var bind))]
                       [(literal? bind) (literal-val bind)]
                       [(macro? bind)
                        (apply-macro bind s ctx state
                                     (lambda (new-s new-state)
                                       (parse new-s state)))]
                       [(not bind) (syntax-error "unbound identifier" s)]
                       [(pair? bind) (syntax-error "cannot expand foreign syntax" s)]
                       [else bind]))]
                  [(null? s) (bad-syntax s)]
                  [else s]))])
      parse)))
