#lang zuo/datum

;; A context is just a distinct identity used in binding tables
(define (make-module-context mod-path)
  (string->uninterned-symbol "module"))

;; A syntactic-closure syntax object pairs a symbol with a context
(define syntactic-closure-tag (string->uninterned-symbol "identifier"))
(define (syntactic-closure sym ctx) (opaque syntactic-closure-tag (cons sym ctx)))
(define (syntactic-closure? v) (and (opaque-ref syntactic-closure-tag v #f) #t))
(define (syntactic-closure-sym sc) (car (opaque-ref syntactic-closure-tag sc #f)))
(define (syntactic-closure-ctx sc) (cdr (opaque-ref syntactic-closure-tag sc #f)))

(define (identifier? v)
  (or (symbol? v)
      (syntactic-closure? v)))
(define (syntax-e x)
  (if (symbol? x)
      x
      (syntactic-closure-sym x)))

(define (datum->syntax ctx d) d)
(define syntax->datum
  (letrec ([syntax->datum
            (lambda (stx)
              (cond
                [(pair? stx) (cons (syntax->datum (car stx))
                                   (syntax->datum (cdr stx)))]
                [(identifier? stx) (syntax-e stx)]
                [else stx]))])
    syntax->datum))

;; Binding information has three parts:
;;   * ctx                : the current binding context
;;   * sym -> ctx         : the per-symbol default context for plain symbols
;;   * ctx -> sym -> bind : the binding table
(define (make-binds ctx sym-hash ctx-hash) (cons ctx (cons sym-hash ctx-hash)))
(define binds-ctx car)
(define binds-sym-hash cadr)
(define binds-ctx-hash cddr)
(define (binds-set-ctx binds ctx) (cons ctx (cdr binds)))
(define (binds-set-ctx-hash binds ctx-hash) (cons (car binds) (cons (cadr binds) ctx-hash)))

(define (binds-create ht ctx)
  (make-binds ctx
              (foldl (lambda (sym sym-hash)
                       (hash-set sym-hash sym ctx))
                     (hash)
                     (hash-keys ht))
              (hash ctx ht)))

;; We don't need scopes, but these functions are here to line
;; up with the set-of-scopes API
(define (make-scope name) #f)
(define (add-scope e scope) e)

;; Install a new binding
(define (add-binding-at binds sym ctx bind)
  (let* ([sym-hash (binds-sym-hash binds)]
         [ctx-hash (binds-ctx-hash binds)])
    (make-binds (binds-ctx binds)
                (hash-set sym-hash sym ctx)
                (hash-set ctx-hash ctx (hash-set (hash-ref ctx-hash ctx (hash)) sym bind)))))
(define (add-binding* binds id bind)
  (if (symbol? id)
      (add-binding-at binds
                      id (binds-ctx binds)
                      bind)
      (add-binding-at binds
                      (syntactic-closure-sym id) (syntactic-closure-ctx id)
                      bind)))

;; Find the binding for an identifier
(define (resolve-at binds sym ctx same-defn-ctx?)
  (and (or (not same-defn-ctx?)
           (eq? ctx (binds-ctx binds)))
       (hash-ref (hash-ref (binds-ctx-hash binds) ctx (hash)) sym #f)))
(define (resolve* binds id same-defn-ctx?)
  (if (symbol? id)
      (resolve-at binds
                  id (hash-ref (binds-sym-hash binds) id (binds-ctx binds))
                  same-defn-ctx?)
      (resolve-at binds
                  (syntactic-closure-sym id) (syntactic-closure-ctx id)
                  same-defn-ctx?)))

(define (new-defn-context* binds)
  (binds-set-ctx binds (string->uninterned-symbol "def")))

;; When we use an imported macro, we need to pull in binding information
;; from the macro's module; the separate module contexts keep different binding
;; information from getting mixed up
(define (merge-binds binds ctx m-binds)
  (let* ([ctx-hash (binds-ctx-hash binds)]
         [m-ctx-hash (binds-ctx-hash m-binds)]
         [new-ctx-hash (hash-set ctx-hash ctx (hash-ref m-ctx-hash ctx (hash)))])
    (binds-set-ctx-hash binds new-ctx-hash)))

(define (bound-identifier=? a b)
  (or (and (syntactic-closure? a)
           (syntactic-closure? b)
           (eq? (syntactic-closure-sym a) (syntactic-closure-sym b))
           (eq? (syntactic-closure-ctx a) (syntactic-closure-ctx b)))
      (eq? a b)))

(include "../mm-common/free-id-eq.zuo")

;; syntax-quote turns a symbol into a syntactic closure, and leaves everything
;; else alone; the closure captures the enclosing context where the symbol is
;; currently bound, or the module context if it's not bound
(define (syntax-quote v mod-ctx binds)
  (letrec ([syntax-quote
            (lambda (v)
              (cond
                [(pair? v) (list 'cons (syntax-quote (car v)) (syntax-quote (cdr v)))]
                [(null? v) '()]
                [(symbol? v)
                 (list 'quote (syntactic-closure v (hash-ref (binds-sym-hash binds) v mod-ctx)))]
                [else v]))])
    (syntax-quote v)))

;; apply a macro; if it's imported, then we'll have to do some work to
;; merge binding information for the providing context
(define (apply-macro m s ctx binds k)
  (let* ([apply-macro
          (lambda (proc binds)
            (k (if (= 4 (bitwise-and (procedure-arity-mask proc) 4))
                   (proc s (lambda (a b) (free-id=? binds a b)))
                   (proc s))
               binds))])
    (cond
      [(defined-macro? m) (apply-macro (defined-macro-proc m) binds)]
      [else
       (let* ([implementation (macro-implementation m)]
              [proc (car implementation)]
              [ctx (cadr implementation)]
              [m-binds (cadr (cdr implementation))])
         (apply-macro proc (merge-binds binds ctx m-binds)))])))

;; convert a local macro to one that can be used as imported elsewhere
(define (make-exported-macro proc ctx binds)
  (make-macro (list proc ctx binds)))
