#lang zuo/datum

;; A module context is just a distinct identity used in binding tables
(define make-module-context
  (lambda (mod-path)
    (string->uninterned-symbol "module")))

;; A syntactic-closure syntax object pairs a symbol with a module context
(define syntactic-closure-tag (string->uninterned-symbol "identifier"))
(define syntactic-closure (lambda (sym ctx) (opaque syntactic-closure-tag (cons sym ctx))))
(define syntactic-closure? (lambda (v) (and (opaque-ref syntactic-closure-tag v #f) #t)))
(define syntactic-closure-sym (lambda (sc) (car (opaque-ref syntactic-closure-tag sc #f))))
(define syntactic-closure-ctx (lambda (sc) (cdr (opaque-ref syntactic-closure-tag sc #f))))

(define identifier? (lambda (v)
                      (or (symbol? v)
                          (syntactic-closure? v))))
(define syntax-e (lambda (x)
                   (if (symbol? x)
                       x
                       (syntactic-closure-sym x))))

(define datum->syntax (lambda (ctx d) d))
(define syntax->datum (letrec ([syntax->datum
                                (lambda (stx)
                                  (cond
                                    [(pair? stx) (cons (syntax->datum (car stx))
                                                       (syntax->datum (cdr stx)))]
                                    [(identifier? stx) (syntax-e stx)]
                                    [else stx]))])
                        syntax->datum))

;; Binding information has a table for the current context (i.e., current module),
;; a two-level table for all other contexts, and the current context:
;;   (cons <hash: sym -> bind> (cons <hash: ctx -> sym -> bind> <ctx>))
(define empty-binds (cons (hash) (cons (hash) #f)))
(define binds-hash car)
(define binds-ctx-hash cadr)
(define binds-ctx cddr)
(define binds-set-hash (lambda (binds ht) (cons ht (cdr binds))))
(define binds-set-ctx-hash (lambda (binds ctx-ht) (cons (car binds) (cons ctx-ht (cddr binds)))))
(define binds-set-ctx (lambda (binds ctx) (cons (car binds) (cons (cadr binds) ctx))))

(define binds-create
  (lambda (ht ctx)
    (binds-set-ctx (binds-set-hash empty-binds ht) ctx)))

(define make-scope (lambda (name) #f))
(define add-scope (lambda (e scope) e))

(define resolve*
  (lambda (binds id)
    (if (syntactic-closure? id)
        (let ([ctx (syntactic-closure-ctx id)]
              [sym (syntactic-closure-sym id)])
          (if (eq? ctx (binds-ctx binds))
              (hash-ref (binds-hash binds) sym #f)
              (let* ([sc-ht (binds-ctx-hash binds)]
                     [ctx-ht (and sc-ht (hash-ref sc-ht ctx #f))])
                (and ctx-ht
                     (hash-ref ctx-ht sym #f)))))
        (hash-ref (binds-hash binds) id #f))))

(define bound-identifier=?
  (lambda (a b)
    (or (and (syntactic-closure? a)
             (syntactic-closure? b)
             (eq? (syntactic-closure-sym a) (syntactic-closure-sym b))
             (eq? (syntactic-closure-ctx a) (syntactic-closure-ctx b)))
        (eq? a b))))

(define merge-binds
  (lambda (binds ctx m-binds)
    (let* ([sc-ht (binds-ctx-hash binds)]
           [new-sc-ht (hash-set sc-ht ctx (binds-hash m-binds))])
      (binds-set-ctx-hash binds new-sc-ht))))

(define add-binding*
  (lambda (binds id binding)
    (let* ([ctx (if (syntactic-closure? id)
                    (syntactic-closure-ctx id)
                    (binds-ctx binds))]
           [sym (if (syntactic-closure? id)
                   (syntactic-closure-sym id)
                   id)])
      (if (eq? ctx (binds-ctx binds))
          (binds-set-hash binds (hash-set (binds-hash binds) id binding))
          (let* ([sc-ht (binds-ctx-hash binds)]
                 [ctx-ht (hash-ref sc-ht ctx (hash))]
                 [new-ctx-ht (hash-set ctx-ht sym binding)]
                 [new-sc-ht (hash-set sc-ht ctx new-ctx-ht)])
            (binds-set-ctx-hash binds new-sc-ht))))))

(define add-core-binding add-binding*)

(include "../mm-common/free-id-eq.zuo")

(define syntax-quote
  (lambda (v ctx)
    (letrec ([syntax-quote
              (lambda (v)
                (cond
                  [(pair? v) (list 'cons (syntax-quote (car v)) (syntax-quote (cdr v)))]
                  [(null? v) '()]
                  [(symbol? v) (list 'quote (syntactic-closure v ctx))]
                  [else v]))])
      (syntax-quote v))))

(define apply-macro
  (lambda (m s ctx binds k)
    (let* ([apply-macro
            (lambda (proc binds)
              (k (if (= 4 (bitwise-and (procedure-arity-mask proc) 4))
                     (proc s (lambda (a b) (free-id=? binds a b)))
                     (proc s))
                 binds))])
      (cond
        [(defined-macro? m) (apply-macro (defined-macro-proc m) binds)]
        [else
         (let* ([implementation (macro-implementation m)]
                [proc (car implementation)]
                [ctx (cadr implementation)]
                [m-binds (cadr (cdr implementation))])
           (apply-macro proc (merge-binds binds ctx m-binds)))]))))

(define make-exported-macro
  (lambda (proc ctx binds)
    (make-macro (list proc ctx binds))))
