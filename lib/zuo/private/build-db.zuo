#lang zuo/base

;; Build results for each target are stored in the target's directory
;; in "_zuo.db". Since multiple targets are likely to be in the same
;; directory, the goal here is to be able to load information for all
;; the targets at once.

;; A timestamp-based SHA-1 cache for input files is stored in
;; "_zuo_tc.db" alongside "_zuo.db" --- in the directory of a target
;; that depends on the input files, not in the input file's directory
;; (which is likely to be in the source tree). An input used by
;; targets in different directories will have information cached in
;; each of those directories. The cache may also include information
;; for non-input targets that are dependencies, just because it's
;; easier to not distinguish when writing.

;; Paths are stored in the ".db" files relative to the file's
;; directory. The format of each file is a top-level sequence of
;;   (<rel-path> . <info>)
;; For "_zuo.db", it's more specifically
;;   (<rel-path> <sha1> (<dep-rel-path> <sha1>) ...)
;; For "_zuo_tc.db", it's
;;   (<rel-path> (<time-secs> . <time-msec>) <sha1>)

(provide db-record-target-sha1s
         db-load-sha1s
         file-sha1/cached
         path->absolute-path)

;; Given a target's absolute path, construct various ".db" paths and
;; send them on to `k`
(define (db-paths abs-path k)
  (let* ([dir+name (split-path abs-path)]
         [dir (car dir+name)]
         [db-path (build-path dir "_zuo.db")]
         [tc-path (build-path dir "_zuo_tc.db")])
    (k db-path tc-path dir (cdr dir+name))))

;; Records the result of a build of `abs-path`, mainly storing the
;; SHA-1 and dep SHA-1s in "_zuo.db", but also recording a timestamp
;; plus SHA-1 for dependencies in "_zuo_tc.db"
(define (db-record-target-sha1s abs-path ts)
  (db-paths
   abs-path
   (lambda (db-path tc-path dir name)
     (define db-content
       (if (file-exists? db-path)
           (read-from-string-all (file->string db-path))
           '()))
     (define tc-content
       (if (file-exists? tc-path)
           (read-from-string-all (file->string tc-path))
           '()))
     (define new-db-content (reassoc (cons name ts) db-content))
     (define new-tc-content
       (foldl (lambda (dep tc-content)
                (define dep-name (car dep))
                (define time (file-timestamp (build-path dir dep-name)))
                (cond
                  [time (reassoc (list dep-name time (cadr dep)) tc-content)]
                  [else tc-content]))
              tc-content
              (cdr ts)))
     (update-file db-path new-db-content)
     (update-file tc-path new-tc-content))))

;; Loads previous-build information for `abs-path`, as well as cached
;; SHA-1s for things that might be dependencies; loading needs to
;; happen only once per directory that has a (non-input) build target
(define (db-load-sha1s abs-path db tc)
  (db-paths
   abs-path
   (lambda (db-path tc-path dir name)
     (define key (string->symbol db-path))
     (cond
       [(hash-ref db key #f) #f]
       [else
        ;; if loading fails, then we'll delete files on the
        ;; grounds that they must be in bad shape
        (define (read-in path table)
          (define c-handle (cleanable-file path))
          (define content (if (file-exists? path)
                              (read-from-string-all (file->string path))
                              '()))
          (define new
            (foldl (lambda (name+val table)
                     (define name (car name+val))
                     (define key (string->symbol (if (relative-path? name)
                                                     (simple-form-path (build-path dir name))
                                                     name)))
                     (hash-set table key (cdr name+val)))
                   table
                   content))
          (cleanable-cancel c-handle)
          new)
        (define new-db (read-in db-path (hash-set db key #t)))
        (define new-tc (read-in tc-path tc))
        (cons new-db new-tc)]))))

;; Helpers to get an input file's SHA-1, possibly cached
(define (file-sha1/cached path time-cache)
  (let ([timestamp (file-timestamp path)])
    (and timestamp
         (let ([cached (and time-cache
                            (hash-ref time-cache
                                      (string->symbol (path->absolute-path path))
                                      #f))])
           (if (and cached
                    (equal? (car cached) timestamp))
               (cadr cached)
               (string-sha1 (file->string path)))))))

;; Atomic write by write-to-temporary-and-move
(define (update-file path new-content)
  (define path-tmp (~a path "-tmp"))
  (display-to-file (string-join (map ~s new-content) "\n") path-tmp :truncate)
  (mv path-tmp path))

;; Like `hash-set`, but for an association list
(define (reassoc pr content)
  (cond
    [(null? content) (list pr)]
    [(string=? (caar content) (car pr)) (cons pr (cdr content))]
    [else (cons (car content) (reassoc pr (cdr content)))]))

(define (file-timestamp path)
  (define s (stat path))
  (and s (list (hash-ref s 'modify-time-seconds)
               (hash-ref s 'modify-time-nanoseconds))))

(define (path->absolute-path p)
  (if (relative-path? p)
      (build-path (hash-ref (runtime-env) 'dir) p)
      p))
