#lang zuo/private/kernel-letrec

;; Implements a less minimal language by adding `and`, `or`, `cond`, and `quasiauote` preprocessing.
;; These will be replaced with variants that cooerate better with bindings after
;; the `defmacromod` layer (but implementing the defmacro layer is a path without these).

(hash 'read-and-eval
      (lambda (str start mod-path)
        (let ([maybe-begin (lambda (l)
                             (if (null? (cdr l))
                                 (car l)
                                   (cons 'begin l)))])
          (letrec ([compile
                    (lambda (s env maybe-name)
                      (let ([recur (lambda (e) (compile e env #f))])
                        (if (pair? s)
                            (if (eq? (car s) 'or)
                                (letrec ([expand-or (lambda (l)
                                                      (if (null? l)
                                                          #f
                                                          (if (pair? l)
                                                              (if (null? (cdr l))
                                                                  (recur (car l))
                                                                  (let ([tmp (string->uninterned-symbol "ortmp")])
                                                                    (list 'let
                                                                          (list (list tmp
                                                                                      (recur (car l))))
                                                                          (list 'if
                                                                                tmp
                                                                                tmp
                                                                                (expand-or (cdr l))))))
                                                              (error "or: bad syntax" s))))])
                                  (expand-or (cdr s)))
                                (if (eq? (car s) 'and)
                                    (letrec ([expand-and (lambda (l)
                                                           (if (null? l)
                                                               #t
                                                               (if (pair? l)
                                                                   (if (null? (cdr l))
                                                                       (recur (car l))
                                                                       (list 'if
                                                                             (recur (car l))
                                                                             (expand-and (cdr l))
                                                                             #f))
                                                                   (error "and: bad syntax" s))))])
                                      (expand-and (cdr s)))
                                    (if (eq? (car s) 'cond)
                                        (let ([no (lambda () (error "cond: bad syntax" s))])
                                          (letrec ([expand-cond (lambda (l)
                                                                  (if (null? l)
                                                                      (void)
                                                                      (if (pair? l)
                                                                          (if (list? (car l))
                                                                              (if (>= (length (car l)) 2)
                                                                                  (if (eq? (car (car l)) 'else)
                                                                                      (if (null? (cdr l))
                                                                                          (recur (maybe-begin (cdr (car l))))
                                                                                          (no))
                                                                                      (list 'if
                                                                                            (recur (car (car l)))
                                                                                            (recur (maybe-begin (cdr (car l))))
                                                                                            (expand-cond (cdr l))))
                                                                                  (no))
                                                                              (no))
                                                                          (no))))])
                                            (expand-cond (cdr s))))
                                        (if (eq? (car s) 'let*)
                                            (letrec ([expand-let* (lambda (l env body)
                                                                    (if (null? l)
                                                                        (compile body env maybe-name)
                                                                        (let ([cl (car l)])
                                                                          (let ([id (car cl)])
                                                                            (list 'let
                                                                                  (list (list id (compile (car (cdr cl)) env id)))
                                                                                  (expand-let* (cdr l) (hash-remove env id) body))))))])
                                              (expand-let* (car (cdr s)) env (maybe-begin (cdr (cdr s)))))
                                            (if (eq? (car s) 'letrec)
                                                (let ([clauses (car (cdr s))])
                                                  (let ([id (car (car clauses))])
                                                    (let ([env (hash-remove env id)])
                                                      (list 'letrec (list (list id
                                                                                (compile (car (cdr (car clauses))) env #f)))
                                                            (compile (maybe-begin (cdr (cdr s))) env maybe-name)))))
                                                (if (eq? (car s) 'let)
                                                    (let ([clauses (car (cdr s))])
                                                      (let ([id (car (car clauses))])
                                                        (list 'let (list (list id
                                                                               (compile (car (cdr (car clauses))) env id)))
                                                              (let ([env (hash-remove env id)])
                                                                (compile (maybe-begin (cdr (cdr s))) env maybe-name)))))
                                                    (if (eq? (car s) 'when)
                                                        (if (>= (length s) 2)
                                                            (list 'if
                                                                  (recur (car (cdr s)))
                                                                  (recur (maybe-begin (cdr (cdr s))))
                                                                  '(void))
                                                            (error "when: bad syntax" s))
                                                        (if (eq? (car s) 'unless)
                                                            (if (>= (length s) 2)
                                                                (list 'if
                                                                      (recur (car (cdr s)))
                                                                      '(void)
                                                                      (recur (maybe-begin (cdr (cdr s)))))
                                                                (error "unless: bad syntax" s))
                                                            (if (eq? (car s) 'lambda)
                                                                (if (>= (length s) 3)
                                                                    (let ([keep-names? #t])
                                                                      (let ([args (car (cdr s))])
                                                                        (letrec ([prune-args (lambda (args env)
                                                                                               (if (null? args)
                                                                                                   env
                                                                                                   (if (symbol? args)
                                                                                                       (hash-remove env args)
                                                                                                       (prune-args (cdr args)
                                                                                                                   (hash-remove env (car args))))))])
                                                                          (let ([body (cdr (cdr s))])
                                                                            (let ([body (compile (maybe-begin body) (prune-args args env) #f)])
                                                                              (if (if keep-names? maybe-name #f)
                                                                                  (let ([name (symbol->string maybe-name)])
                                                                                    (list 'lambda args name body))
                                                                                  (list 'lambda args body)))))))
                                                                    (error "lambda: bad syntax" s))
                                                                (if (eq? (car s) 'quote)
                                                                    s
                                                                    (cons (recur (car s))
                                                                          (recur (cdr s)))))))))))))
                            (if (symbol? s)
                                (let ([v (hash-ref env s env)])
                                  (if (eq? v env)
                                      s
                                      (if (symbol? v)
                                          (list 'quote v)
                                          (if (pair? v)
                                              (list 'quote v)
                                              v))))
                                s))))])
            (let ([es (read-from-string-all (substring str start (string-length str)))])
              (if (if (null? es)
                      #t
                      (pair? (cdr es)))
                  (error "only one expression allowed")
                  (let ([e (car es)])
                    (if (if (pair? e)
                            (not (eq? (car e) 'let*))
                            #t)
                        (error "expected a let* form")
                        (letrec ([partial-eval-compile
                                  (lambda (clauses env)
                                    (if (null? clauses)
                                        (eval (compile (car (cdr (cdr e))) env #f))
                                        (let ([cl (car clauses)])
                                          (let ([id (car cl)])
                                            (let ([v (eval (compile (car (cdr cl)) env id))])
                                              (partial-eval-compile (cdr clauses)
                                                                    (hash-set env id v)))))))])
                          (partial-eval-compile (car (cdr e)) (kernel-namespace)))))))))))
