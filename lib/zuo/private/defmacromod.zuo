#lang zuo/private/qq-and-or

;; This layer implements a basic module and macro layer,
;; defmacro-style. So, it's not hygienic, but it handles binding more
;; properly that `zuo/kernel` in the sense that keywords can be
;; shadowed, and module imports and exports can renaming bindings. The
;; `eval` used here is the `zuo/kernel` evaluator, so the expansion of
;; this layer doesn't rely on `zuo/qq-and-or` or `zuo/letrec`.

(let* ([cddr (lambda (p) (cdr (cdr p)))]
       [cadr (lambda (p) (car (cdr p)))]

       [map (lambda (f vs)
              (letrec ([map (lambda (vs)
                              (if (null? vs)
                                  '()
                                  (cons (f (car vs)) (map (cdr vs)))))])
                (map vs)))]
       [map2 (lambda (f vs v2s)
               (letrec ([map (lambda (vs v2s)
                               (if (null? vs)
                                   '()
                                   (cons (f (car vs) (car v2s))
                                         (map (cdr vs) (cdr v2s)))))])
                 (map vs v2s)))]
       [foldl (lambda (f init vs)
                (letrec ([fold (lambda (vs accum)
                                 (if (null? vs)
                                     accum
                                     (fold (cdr vs) (f (car vs) accum))))])
                  (fold vs init)))]
       [member? (letrec ([member? (lambda (v l)
                                    (if (null? l)
                                        #f
                                        (if (eq? v (car l))
                                            #t
                                            (member? v (cdr l)))))])
                  member?)]

       ;; poor man's structs
       [make-maker (lambda (tag) (lambda (v) (cons tag v)))]
       [make-? (lambda (tag) (lambda (v) (and (pair? v) (eq? tag (car v)))))]
       [make-ref (lambda (tag) cdr)]

       [make-macro (make-maker 'macro)]
       [macro? (make-? 'macro)]

       [make-core-form (make-maker 'core-form)]
       [core-form? (make-? 'core-form)]
       [syntax-id (make-ref 'core-form)]

       [make-local (make-maker 'local)]
       [local? (make-? 'local)]
       [local-id (make-ref 'local)]

       [make-local-variable (make-maker 'local-variable)]

       [make-defined (make-maker 'defined)]
       [defined? (make-? 'defined)]

       [make-defined-macro (make-maker 'defined-macro)]
       [defined-macro? (make-? 'defined-macro)]
       [defined-macro-id (make-ref 'defined-macro)]

       [variable? (lambda (v) (and (pair? v)
                                   (let ([t (car v)])
                                     (or (eq? t 'local-variable)
                                         (eq? t 'defined)))))]
       [variable-var cdr] ; can be id or variable value

       [make-literal (make-maker 'literal)]
       [literal? (make-? 'literal)]
       [literal-val (make-ref 'literal)]

       [top-binds (foldl (lambda (id binds)
                           (hash-set binds id (make-core-form id)))
                         (kernel-namespace)
                         '(lambda let letrec quote if begin
                                  define require provide))]

       [export-bind (lambda (bind)
                      ;; convert a local binding into one suitable to import
                      (cond
                        [(defined? bind) (make-local-variable (variable-var bind))]
                        [else bind]))]

       [gensym (lambda (s) (string->uninterned-symbol (~a s)))]
       [maybe-begin (lambda (d) (if (null? (cdr d)) (car d) (cons 'begin d)))]
       [name-lambda (lambda (form id)
                      (if (and (pair? form)
                               (eq? (car form) 'lambda))
                          ;; `zuo/kernel` recognizes this pattern to name the form
                          `(lambda ,(cadr form) ,(~a id) ,(cadr (cdr form)))
                          form))]

       [syntax-error (lambda (msg s) (error (~a msg ": " (~w s))))]
       [bad-syntax (lambda (s) (syntax-error "bad syntax" s))]
       [duplicate-identifier (lambda (id s) (error "duplicate identifier" id s))]

       [expand-define (lambda (s binds k)
                        (unless (and (list? s) (= 3 (length s))) (bad-syntax s))
                        (let* ([id (cadr s)]
                               [id-bind (hash-ref binds id #f)])
                          (when (or (defined? id-bind)
                                    (defined-macro? id-bind))
                            (error "duplicate definition" id))
                          (let* ([def-id (gensym id)]
                                 [var (variable id)]
                                 [new-binds (hash-set (hash-set binds id (make-defined var))
                                                      def-id (make-local def-id))]
                                 [new-s `(variable-set! ,var ,(cadr (cdr s)))])
                            (k new-s new-binds))))]

       [expand-provide (lambda (s binds provides)
                         (unless (list? s) (bad-syntax s))
                         (foldl (lambda (p provides)
                                  (let* ([add-provide (lambda (p as-p)
                                                        (let* ([old-p (hash-ref provides as-p #f)])
                                                          (when (and old-p
                                                                     (not (eq? old-p p)))
                                                            (syntax-error "already provided as different binding" as-p))
                                                          (hash-set provides as-p p)))]
                                         [bad-provide-form (lambda () (syntax-error "bad provide clause" p))])
                                    (cond
                                      [(symbol? p) (add-provide p p)]
                                      [(pair? p)
                                       (unless (list? p) (bad-provide-form))
                                       (let ([form (car p)])
                                         (cond
                                           [(eq? form 'rename-out)
                                            (foldl (lambda (rn)
                                                     (unless (and (list? rn) (= 2 (length rns))
                                                                  (symbol? (car rns)) (symbol? (cadr rns)))
                                                       (base-provide-form))
                                                     (add-provide (car rn) (cadr rn)))
                                                   (cdr p))]
                                           [else (bad-provide-form)]))]
                                      [else (bad-provide-form)])))
                                provides
                                (cdr s)))]
       [expand-require (lambda (s binds mod-path)
                         (let* ([check-renames
                                 ;; syntax check on renaming clauses `ns`
                                 (lambda (ns id-ok?)
                                   (map (lambda (n) (unless (or (and id-ok?
                                                                     (symbol? n))
                                                                (and (list? n)
                                                                     (= 2 (length n))
                                                                     (symbol? (car n))
                                                                     (symbol? (cadr n))))
                                                      (bad-syntax r)))
                                        ns))]
                                [make-rename-filter
                                 ;; used to apply `ns` renaming clauses to an imported identifier
                                 (lambda (ns only?)
                                   (lambda (id)
                                     (letrec ([loop (lambda (ns)
                                                      (cond
                                                        [(null? ns) (if only? #f id)]
                                                        [(eq? (car ns) id) id]
                                                        [(and (pair? (car ns))
                                                              (eq? (car (car ns)) id))
                                                         (cadr (car ns))]
                                                        [else (loop (cdr ns))]))])
                                       (loop ns))))]
                                [make-provides-checker
                                 ;; used to check whether set of provided is consistent with `ns`
                                 (lambda (ns)
                                   (lambda (provides)
                                     (map (lambda (n)
                                            (let ([id (if (pair? n) (car n) n)])
                                              (unless (hash-ref provides id #f)
                                                (error "identifier is not in required set" id))))
                                          ns)))])
                           ;; parse each `require` clause `r:
                           (foldl (lambda (r binds)
                                    (let* ([req-path+filter+check
                                            (cond
                                              [(string? r) (list r (lambda (id) id) void)]
                                              [(symbol? r) (list r (lambda (id) id) void)]
                                              [(pair? r)
                                               (unless (and (list? r) (pair? (cdr r))) (bad-syntax r))
                                               (let* ([ns (cddr r)])
                                                 (cond
                                                   [(eq? (car r) 'only-in)
                                                    (check-renames ns #t)
                                                    (list (cadr r) (make-rename-filter ns #t) (make-provides-checker ns))]
                                                   [(eq? (car r) 'rename-in)
                                                    (check-renames ns #f)
                                                    (list (cadr r) (make-rename-filter ns #f) (make-provides-checker ns))]
                                                   [else (bad-syntax r)]))]
                                              [else (bad-syntax r)])]
                                           [req-path (car req-path+filter+check)]
                                           [filter (cadr req-path+filter+check)]
                                           [check (cadr (cdr req-path+filter+check))]
                                           [mod (dynamic-require (if (string? req-path)
                                                                     (path->complete-path req-path (car (split-path mod-path)))
                                                                     req-path))]
                                           [provides (hash-ref mod 'provides #f)])
                                      (unless provides (error "not a compatible module" r))
                                      (check provides)
                                      ;; add each provided binding (except as filtered)
                                      (foldl (lambda (id binds)
                                               (let* ([as-id (filter id)])
                                                 (cond
                                                   [(not as-id) binds]
                                                   [else
                                                    ;; check whether it's bound already
                                                    (let* ([current-bind (hash-ref binds as-id #f)]
                                                           [req-bind (hash-ref provides id #f)])
                                                      (cond
                                                        [(not current-bind)
                                                         ;; not already bound, so import is ok
                                                         (hash-set binds as-id req-bind)]
                                                        [(eq? current-bind req-bind)
                                                         ;; re-import of same variable or primitive, also ok
                                                         binds]
                                                        [(or (defined? current-bind)
                                                             (defined-macro? current-bind))
                                                         ;; definition shadows import
                                                         binds]
                                                        [else
                                                         (error "identifier is already imported" as-id)]))])))
                                             binds
                                             (hash-keys provides))))
                                  binds
                                  (cdr s))))]

       [expand-top-sequence
        ;; expand top-level forms and gather imports and definitions
        (lambda (es binds mod-path)
          (letrec ([expand-top
                    (lambda (es accum binds provides)
                      (cond
                        [(null? es) (list (reverse accum) binds provides)]
                        [else
                         (let ([s (car es)])
                           (cond
                             [(pair? s)
                              (let* ([rator (car s)]
                                     [bind (and (symbol? rator)
                                                (hash-ref binds rator #f))])
                                (cond
                                  [(macro? bind)
                                   (expand-top (cons (apply-macro bind s) (cdr es)) accum binds provides)]
                                  [(core-form? bind)
                                   (let ([bind (syntax-id bind)])
                                     (cond
                                       [(eq? bind 'begin)
                                        (unless (list? s) (bad-syntax s))
                                        (expand-top (append (cdr s) (cdr es)) accum binds provides)]
                                       [(eq? bind 'define)
                                        (expand-define s
                                                       binds
                                                       (lambda (new-s new-binds)
                                                         (expand-top (cdr es) (cons new-s accum) new-binds provides)))]
                                       [(eq? bind 'provide)
                                        (let ([new-provides (expand-provide s binds provides)])
                                          (expand-top (cdr es) accum binds new-provides))]
                                       [(eq? bind 'require)
                                        (let ([new-binds (expand-require s binds mod-path)])
                                          (expand-top (cdr es) accum new-binds provides))]
                                       [else
                                        (expand-top (cdr es) (cons s accum) binds provides)]))]
                                  [else (expand-top (cdr es) (cons s accum) binds provides)]))]
                             [else (expand-top (cdr es) (cons s accum) binds provides)]))]))])
            (expand-top es '() binds (hash))))]

       [parse-lambda (lambda (s binds parse)
                       (unless (>= (length s) 3) (bad-syntax s))
                       (let* ([formals (cadr s)]
                              [new-formals (letrec ([reformal (lambda (f seen)
                                                                (cond
                                                                  [(null? f) '()]
                                                                  [(symbol? f)
                                                                   (when (member? f seen)
                                                                     (duplicate-identifier f s))
                                                                   (gensym f)]
                                                                  [(pair? f)
                                                                   (let* ([a (car f)])
                                                                     (unless (symbol? a) (bad-syntax s))
                                                                     (cons (reformal a seen)
                                                                           (reformal (cdr f) (cons a seen))))]
                                                                  [else (bad-syntax s)]))])
                                             (reformal formals '()))]
                              [binds (letrec ([add-formals (lambda (binds formals new-formals)
                                                             (cond
                                                               [(symbol? formals)
                                                                (hash-set binds formals (make-local new-formals))]
                                                               [(pair? formals)
                                                                (add-formals (add-formals binds (cdr formals) (cdr new-formals))
                                                                             (car formals)
                                                                             (car new-formals))]
                                                               [else binds]))])
                                       (add-formals binds formals new-formals))])
                         `(lambda ,new-formals
                            ,(parse (maybe-begin (cddr s)) binds))))]

       [nest-bindings (lambda (new-cls body)
                        (letrec ([nest-bindings (lambda (new-cls)
                                                  (if (null? new-cls)
                                                      body
                                                      `(let (,(car new-cls))
                                                         ,(nest-bindings (cdr new-cls)))))])
                          (nest-bindings (reverse new-cls))))]
       [parse-let (lambda (s binds parse)
                    (unless (>= (length s) 3) (bad-syntax s))
                    (let* ([cls (cadr s)]
                           [orig-binds binds])
                      (unless (list? cls) (bad-syntax s))
                      (letrec ([parse-clauses
                                (lambda (cls new-cls binds seen)
                                  (cond
                                    [(null? cls)
                                     (next-bindings (reverse new-cls)
                                                    (parse (maybe-begin (cddr s)) binds))]
                                    [else
                                     (let* ([cl (car cls)])
                                       (unless (list? cl) (bad-syntax s))
                                       (unless (= 2 (length cl)) (bad-syntax s))
                                       (let* ([id (car cl)])
                                         (unless (symbol? id) (bad-syntax s))
                                         (when (member? id seen)
                                           (duplicate-identifier id s))
                                         (let* ([new-id (gensym id)])
                                           (parse-clauses (cdr cls)
                                                          (cons (list new-id (name-lambda
                                                                              (parse (cadr cl) orig-binds)
                                                                              id))
                                                                new-cls)
                                                          (hash-set binds id (make-local new-id))
                                                          (cons id seen)))))]))])
                        (parse-clauses cls '() binds '()))))]

       [parse-letrec (lambda (s binds parse)
                       (unless (>= (length s) 3) (bad-syntax s))
                       (let* ([cls (cadr s)]
                              [orig-binds binds])
                         (unless (list? cls) (bad-syntax s))
                         ;; use mutable variables to tie knots
                         (letrec ([bind-all (lambda (x-cls new-ids binds seen)
                                              (cond
                                                [(null? x-cls)
                                                 (nest-bindings
                                                  (map (lambda (new-id)
                                                         `[,new-id (,variable ',new-id)])
                                                       new-ids)
                                                  `(begin
                                                     (begin . ,(map2 (lambda (cl new-id)
                                                                       `(,variable-set! ,(car new-ids)
                                                                                        ,(name-lambda
                                                                                          (parse (cadr (car cls)) binds)
                                                                                          (car (car cls)))))
                                                                     cls
                                                                     (reverse new-ids)))
                                                     ,(parse (maybe-begin (cddr s)) binds)))]
                                                [else
                                                 (let* ([cl (car x-cls)])
                                                   (unless (list? cl) (bad-syntax s))
                                                   (unless (= 2 (length cl)) (bad-syntax s))
                                                   (let* ([id (car cl)])
                                                     (unless (symbol? id) (bad-syntax s))
                                                     (when (member? id seen) (duplicate-identifier id s))
                                                     (let ([new-id (gensym id)])
                                                       (bind-all (cdr x-cls)
                                                                 (cons new-id new-ids)
                                                                 (hash-set binds id (make-local-variable new-id))
                                                                 (cons id seen)))))]))])
                           (bind-all cls '() binds '()))))])
  (letrec ([parse
            ;; parse an expression, substituing variables based on `binds`
            (lambda (s binds)
              (cond
                [(pair? s)
                 (let* ([rator (car s)]
                        [bind (and (symbol? rator)
                                   (hash-ref binds rator #f))])
                   (cond
                     [(macro? bind)
                      (parse (apply-macro bind s) binds)]
                     [(core-form? bind)
                      (unless (list? s) (bad-syntax s))
                      (let ([bind (syntax-id bind)])
                        (cond
                          [(eq? bind 'lambda)
                           (parse-lambda s binds parse)]
                          [(eq? bind 'let)
                           (parse-let s binds parse)]
                          [(eq? bind 'letrec)
                           (parse-letrec s binds parse)]
                          [(eq? bind 'quote)
                           (unless (= 2 (length s)) (bad-syntax s))
                           `(quote ,(cadr s))]
                          [(eq? bind 'if)
                           (unless (= 4 (length s)) (bad-syntax s))
                           `(if ,(parse (cadr s) binds) ,(parse (cadr (cdr s)) binds) ,(parse (cadr (cddr s)) binds))]
                          [(eq? bind 'begin)
                           (cons bind (map (lambda (e) (parse e binds)) (cdr s)))]
                          [else
                           (map (lambda (e) (parse e binds)) s)]))]
                     [else (map (lambda (e) (parse e binds)) s)]))]
                [(symbol? s)
                 (let* ([bind (hash-ref binds s #f)])
                   (cond
                     [(core-form? bind) (bad-syntax s)]
                     [(local? bind) (local-id bind)]
                     [(variable? bind) `(,variable-ref ,(variable-var bind))]
                     [(literal? bind) (literal-val bind)]
                     [bind (if (eq? bind eval)
                               ;; substitute our evalutation
                               (lambda (e) (eval (parse s top-binds)))
                               bind)]
                     [else (error "unbound identifier" s)]))]
                [(null? s) (bad-syntax s)]
                [else s]))])

    (hash 'read-and-eval
          (lambda (str start mod-path)
            (let* ([es (read-from-string-all (substring str start (string-length str)))]
                   [es+binds+provides (expand-top-sequence es top-binds mod-path)]
                   [es (car es+binds+provides)]
                   [binds (cadr es+binds+provides)]
                   [provides (cadr (cdr es+binds+provides))]
                   [outs (letrec ([provide-out
                                   (lambda (as-ids outs)
                                     (cond
                                       [(null? as-ids) outs]
                                       [else
                                        (let* ([as-id (car as-ids)]
                                               [id (hash-ref provides as-id #f)]
                                               [bind (hash-ref binds id #f)])
                                          (unless bind (error "provided identifier not bound" id))
                                          (provide-out (cdr as-ids) (hash-set outs as-id (export-bind bind))))]))])
                           (provide-out (hash-keys provides) (hash)))])
              (eval (cons 'begin (map (lambda (e) (parse e binds)) es)))
              (hash 'provides outs))))))
