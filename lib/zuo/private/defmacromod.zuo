#lang zuo/private/qq-and-or

;; This layer implements a basic module and macro layer,
;; defmacro-style. So, it's not hygienic, but it handles binding more
;; properly that `zuo/kernel` in the sense that keywords can be
;; shadowed, and module imports and exports can renaming bindings. The
;; `eval` used here is the `zuo/kernel` evaluator, so the expansion of
;; this layer doesn't rely on `zuo/qq-and-or` or `zuo/letrec`.

(hash 'read-and-eval
      (lambda (str start)
        (let* ([es (read-from-string-all (substring str start (string-length str)))]
               [binds (kernel-namespace)]
               [macro? (lambda (v) (and (pair? v) (eq? 'macro (car v))))]
               [make-syntax (lambda (s) (cons 'syntax s))]
               [syntax? (lambda (v) (and (pair? v) (eq? 'syntax (car v))))]
               [syntax-id cdr]
               [binds (letrec ([make-syntax-binds (lambda (ht l)
                                                    (if (null? l)
                                                        ht
                                                        (make-syntax-binds (hash-set ht (car l) (make-syntax (car l)))
                                                                           (cdr l))))])
                        (make-syntax-binds binds '(lambda let letrec quote if begin
                                                          define require provide)))]
               [top-binds binds]
               [cddr (lambda (p) (cdr (cdr p)))]
               [cadr (lambda (p) (car (cdr p)))]
               [bad-syntax (lambda (s) (error "bad syntax" s))]
               [duplicate-identifier (lambda (id s) (error "duplicate identifier" id s))]
               [gensym (lambda (s) (string->uninterned-symbol (~a s)))]
               [make-local (lambda (v) (cons 'local v))]
               [local? (lambda (v) (and (pair? v) (eq? 'local (car v))))]
               [local-id cdr]
               [make-local-variable (lambda (v) (cons 'local-variable v))]
               [local-variable? (lambda (v) (and (pair? v) (eq? 'local-variable (car v))))]
               [local-variable-id cdr]
               [member (lambda (v l) (letrec ([member (lambda (v l)
                                                        (if (null? l)
                                                            #f
                                                            (if (eq? v (car l))
                                                                #t
                                                                (member v (cdr l)))))])
                                       (member v l)))]
               [maybe-begin (lambda (d) (if (null? (cdr d)) (car d) (cons 'begin d)))]
               [name-lambda (lambda (form id)
                              (if (and (pair? form)
                                       (eq? (car form) 'lambda))
                                  `(lambda ,(cadr form) ,(~a id) ,(cadr (cdr form)))
                                  form))]
               [map (lambda (f es)
                      (letrec ([map (lambda (es)
                                      (cond
                                        [(null? es) '()]
                                        [else (cons (f (car es))
                                                    (map (cdr es)))]))])
                        (map es)))])
          (letrec ([rebind
                    (lambda (s binds)
                      (cond
                        [(pair? s)
                         (let ([rator (car s)])
                           (let* ([bind (and (symbol? rator)
                                             (hash-ref binds rator #f))])
                             (cond
                               [(macro? bind)
                                (get-vars (cons (apply-macro bind s)
                                                (cdr es))
                                          binds)]
                               [(syntax? bind)
                                (unless (list? s) (bad-syntax s))
                                (let ([bind (syntax-id bind)])
                                  (cond
                                    [(eq? bind 'lambda)
                                     (unless (>= (length s) 3) (bad-syntax s))
                                     (let* ([formals (cadr s)]
                                            [new-formals (letrec ([reformal (lambda (f seen)
                                                                              (cond
                                                                                [(null? f) '()]
                                                                                [(symbol? f)
                                                                                 (when (member f seen)
                                                                                   (duplicate-identifier f s))
                                                                                 (gensym f)]
                                                                                [(pair? f)
                                                                                 (let* ([a (car f)])
                                                                                   (unless (symbol? a)
                                                                                     (base-syntax s))
                                                                                   (when (member a seen)
                                                                                     (duplicate-identifier a s))
                                                                                   (cons (gensym a)
                                                                                         (reformal (cdr f) (cons a seen))))]
                                                                                [else (bad-syntax s)]))])
                                                           (reformal formals '()))]
                                            [binds (letrec ([add-formals (lambda (binds formals new-formals)
                                                                           (cond
                                                                             [(symbol? formals) (hash-set binds formals (make-local new-formals))]
                                                                             [(pair? formals) (add-formals (add-formals binds (cdr formals) (cdr new-formals))
                                                                                                           (car formals)
                                                                                                           (car new-formals))]
                                                                             [else binds]))])
                                                     (add-formals binds formals new-formals))])
                                       `(lambda ,new-formals
                                          ,(rebind (maybe-begin (cddr s)) binds)))]
                                    [(eq? bind 'let)
                                     (unless (>= (length s) 3) (bad-syntax s))
                                     (let* ([cls (cadr s)]
                                            [orig-binds binds])
                                       (unless (list? cls) (bad-syntax s))
                                       (letrec ([rebind-clauses
                                                 (lambda (cls new-cls binds seen)
                                                   (cond
                                                     [(null? cls) (letrec ([nest-bindings (lambda (new-cls)
                                                                                            (if (null? new-cls)
                                                                                                (rebind (maybe-begin (cddr s)) binds)
                                                                                                `(let (,(car new-cls))
                                                                                                   ,(nest-bindings (cdr new-cls)))))])
                                                                    (nest-bindings (reverse new-cls)))]
                                                     [else
                                                      (let* ([cl (car cls)])
                                                        (unless (list? cl) (bad-syntax s))
                                                        (unless (= 2 (length cl)) (bad-syntax s))
                                                        (let* ([id (car cl)])
                                                          (unless (symbol? id) (bad-syntax s))
                                                          (when (member id seen)
                                                            (duplicate-identifier id s))
                                                          (let* ([new-id (gensym id)])
                                                            (rebind-clauses (cdr cls)
                                                                            (cons (list new-id (name-lambda
                                                                                                (rebind (cadr cl) orig-binds)
                                                                                                id))
                                                                                  new-cls)
                                                                            (hash-set binds id (make-local new-id))
                                                                            (cons id seen)))))]))])
                                         (rebind-clauses cls '() binds '())))]
                                    [(eq? bind 'letrec)
                                     (unless (>= (length s) 3) (bad-syntax s))
                                     (let* ([cls (cadr s)]
                                            [orig-binds binds])
                                       (unless (list? cls) (bad-syntax s))
                                       ;; use mutable variables to tie knots
                                       (letrec ([bind-all (lambda (x-cls new-ids binds seen)
                                                            (cond
                                                              [(null? x-cls)
                                                               `(let ,(letrec ([var-clauses
                                                                                (lambda (new-ids)
                                                                                  (cond
                                                                                    [(null? new-ids) '()]
                                                                                    [else
                                                                                     (cons
                                                                                      `[,(car new-ids) (,variable ',(car new-ids))]
                                                                                      (var-clauses (cdr new-ids)))]))])
                                                                        (var-clauses new-ids))
                                                                  (begin
                                                                    (begin . ,(letrec ([rebind-clauses
                                                                                        (lambda (cls new-ids)
                                                                                          (cond
                                                                                            [(null? cls) '()]
                                                                                            [else
                                                                                             (cons
                                                                                              `(,variable-set! ,(car new-ids)
                                                                                                               ,(name-lambda
                                                                                                                 (rebind (cadr (car cls)) binds)
                                                                                                                 (car (car cls))))
                                                                                              (rebind-clauses (cdr cls) (cdr new-ids)))]))])
                                                                                (rebind-clauses cls (reverse new-ids))))
                                                                    ,(rebind (maybe-begin (cddr s)) binds)))]
                                                              [else
                                                               (let* ([cl (car x-cls)])
                                                                 (unless (list? cl) (bad-syntax s))
                                                                 (unless (= 2 (length cl)) (bad-syntax s))
                                                                 (let* ([id (car cl)])
                                                                   (unless (symbol? id) (bad-syntax s))
                                                                   (when (member id seen) (duplicate-identifier id s))
                                                                   (let ([new-id (gensym id)])
                                                                     (bind-all (cdr x-cls)
                                                                               (cons new-id new-ids)
                                                                               (hash-set binds id (make-local-variable new-id))
                                                                               (cons id seen)))))]))])
                                         (bind-all cls '() binds '())))]
                                    [(eq? bind 'quote)
                                     (unless (= 2 (length s)) (bad-syntax s))
                                     `(quote ,(cadr s))]
                                    [(eq? bind 'if)
                                     (unless (= 4 (length s)) (bad-syntax s))
                                     `(if ,(rebind (cadr s) binds) ,(rebind (cadr (cdr s)) binds) ,(rebind (cadr (cddr s)) binds))]
                                    [(eq? bind 'begin)
                                     (cons bind (map (lambda (e) (rebind e binds)) (cdr s)))]
                                    [else
                                     (map (lambda (e) (rebind e binds)) s)]))]
                               [else (map (lambda (e) (rebind e binds)) s)])))]
                        [(symbol? s)
                         (let ([bind (hash-ref binds s #f)])
                           (cond
                             [(syntax? bind) (bad-syntax s)]
                             [(local? bind) (local-id bind)]
                             [(local-variable? bind) `(,variable-ref ,(local-variable-id bind))]
                             [bind (if (eq? bind eval)
                                       ;; substitute our evalutation
                                       (lambda (e) (eval (rebind s top-binds)))
                                       bind)]
                             [else (error "unbound identifier" s)]))]
                        [(pair? s)
                         (unless (list? s) (bad-syntax s))
                         (map (lambda (e) (rebind e binds)) s)]
                        [(null? s) (bad-syntax s)]
                        [else s]))])
            (eval (cons 'begin (map (lambda (e) (rebind e binds)) es)))))))
